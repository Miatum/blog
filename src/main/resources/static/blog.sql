/*
 Navicat Premium Data Transfer

 Source Server         : 本地
 Source Server Type    : MySQL
 Source Server Version : 80017
 Source Host           : localhost:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 80017
 File Encoding         : 65001

 Date: 12/05/2021 17:02:58
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for blog
-- ----------------------------
DROP TABLE IF EXISTS `blog`;
CREATE TABLE `blog`  (
  `id` int(4) UNSIGNED ZEROFILL NOT NULL AUTO_INCREMENT,
  `state_id` int(4) UNSIGNED NULL DEFAULT 3,
  `title` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `intro` varchar(400) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `cover` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `type_id` int(4) NULL DEFAULT NULL,
  `tag_id` int(4) NULL DEFAULT NULL,
  `author` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `date` datetime NULL DEFAULT NULL,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `resource_path` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `featured` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '0',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `type_id`(`type_id`) USING BTREE,
  INDEX `tag_id`(`tag_id`) USING BTREE,
  CONSTRAINT `tag_id` FOREIGN KEY (`tag_id`) REFERENCES `tag` (`id`) ON DELETE RESTRICT ON UPDATE CASCADE,
  CONSTRAINT `type_id` FOREIGN KEY (`type_id`) REFERENCES `type` (`id`) ON DELETE RESTRICT ON UPDATE CASCADE
) ENGINE = InnoDB AUTO_INCREMENT = 76 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog
-- ----------------------------
INSERT INTO `blog` VALUES (0004, 2, 'AJAX基础用法', '前后端交互的主要方式之一，Form表单方式只要了解相关的HTML组件属性即可使用；而AJAX则主要是Javascript的使用，很多框架也基于原生方法做了封装。', 'd43ddf5db7d843bc9b019b88609f73ce.jpg', 1, 11, 'miatum', '2020-10-02 14:09:35', '# Ajax基础用法\n###### JavaScript写法\n    var xhr = new HttpRequest()\n    xhr.open(\'POST/GET\' , \'url\')\n    xhr.send(data)\n###### jQuery写法\n    $.ajax({\n    type : \"POST\",\n    url : \"/url\",\n    contentType : \"application/json\",\n    dataType : \"json\",\n    data : JSON.stringify(data),\n    success : function (result) {\n                    console.log(result);\n                },\n              error : function(e){\n                    console.log(e.status);\n                    console.log(e.responseText);\n              }\n    })\n###### axios写法\n```\naxios.post(\'url\', paras)\n  .then(response => {\n  })\n  .catch(error => {\n  })\n```\n\n###### 注意事项\n- 前端需要传空值时，不能赋值成null，交互都是以string进行的，null传到后端即\"null\"。如果该参数为某类的一个属性，传参时直接省略该参数即可，后端参数类型设为该类，此时该属性值会自动解析为空值；\neg: 新增用户，用户id不用传，由数据库自动递增，后端controller：\n```java\n@RequestMapping(\"/addUser\")\npublic String controller(User user){\n	return \"\";\n}\npublic class User{\n	int id;\n	String userName;\n	String password;\n}\n```\n前端form表单形式(省略id`<input>`标签)：\n```html\n<form>\n	<input name=\"userName\">\n	<input name=\"password\">\n</form>\n```\n前端Ajax形式发送JSON：\n```json\n[\"userName\":\"admin\",\"password\":\"123\"]\n```\n前端Ajax形式拼接请求头：\n```javascript\nxhr.open(\'POST\',\'/addUser?id&userName=admin&password=123\')\n//或者直接省略id\nxhr.open(\'POST\',\'/addUser?userName=admin&password=123\')\n```\n- 在传递Json对象时，记得调用JSON.Stringify()函数，将其转成字符串。\n', NULL, '1');
INSERT INTO `blog` VALUES (0005, 2, '范型', '本意是想让方法能够适用于更多类型参数，于是了解到范型。', '2d729e01a4e44242aeca892193507ae7.jpg', 1, 7, 'miatum', '2020-10-02 14:12:17', '在不确定参数具体类型时，可使用范型，达到方法可以接收任何类型的参数，如：\n```java\npublic class DataTransform {\n    public static <T> JSONObject forLayUiTable(List<T> list){\n        /**\n        *@Author: miatum\n        *@Description: 将list按layui数据表格要求格式转JSON,使用范型可以让该方法能同时接收Blog、Blog_Tag、Blog_Type、User\n        *@Date: 8:25 2020/9/28\n        */\n        JSONObject jsonObject=new JSONObject();\n        jsonObject.put(\"code\",0);\n        jsonObject.put(\"count\",list.size());\n        jsonObject.put(\"msg\",\"\");\n        jsonObject.put(\"data\",list);\n        return jsonObject;\n    }\n}\n```', NULL, '1');
INSERT INTO `blog` VALUES (0006, 2, 'Thyme leaf基础用法', 'Thyme leaf是spring boot推荐的模板引擎，其内联表达式可以运用在页面内DOM元素属性、CSS、Javascript里。', 'ac35dac3d46c4eeeb73102657060cdde.jpg', 1, 9, 'miatum', '2020-10-02 14:13:01', '# Thymeleaf基础用法\n一个模板引擎罢了，真不熟。\n依赖：\n```xml\n    <dependency>\n    	<groupId>org.springframework.boot</groupId>\n    	<artifactId>spring-boot-starter-thymeleaf</artifactId>\n    </dependency>\n```\n## 问题集锦\n- 在模板中使用layui数据表格时，会出现[[]]连写的情况，但[[]]在thyme leaf中为内联表达式，解决方法:\n[\n[\n]\n]\n就硬换行分开写就行。\n- controller无法跳转页面。犯病情况有很多种：\n1. 1、用了@RestController或者@ResponseBody，这样只能返回字符串。\n2. 2、用Ajax请求，因为用于页面跳转的情况一般只是为了页面初始化带有数据，而Ajax则是数据交互时使用，Ajax是需要处理返回信息的，因此controller会将整个页面的源码作为string返回回去。\n3. 3、确保模板名字正确，以及模板内容无误。', NULL, '1');
INSERT INTO `blog` VALUES (0007, 2, 'CSS基础知识', 'CSS，层叠样式表，配合HTML元素实现对页面的渲染。', 'd9f6086e013f4811b826ca24996e856e.jpg', 1, 10, 'miatum', '2020-10-02 14:16:29', '## 标签\n    @media (max/min-width/height){\n    css语句\n    }\n--根据判断视窗大小执行CSS。\n## 单位\nvw  相对于视口的宽度。视口被均分为100单位的vw(即浏览器可视区) 100vw = 可视区宽度\n\nvh  相对于视口的高度。视口被均分为100单位的vh(即浏览器可视区) 100vh  = 可视区高度\n\nvmin/vm 相对于视口的宽度或高度中较小的那个。其中最小的那个被均分为100单位的vmin（即vm）', NULL, '1');
INSERT INTO `blog` VALUES (0009, 1, '王婷', '年年岁岁花相似，岁岁年年人不同。', 'f687e430bd344471b702cfaa3a65ae8b.jpg', 8, 15, 'miatum', '2020-10-04 04:27:54', '## 不知道怎么回事，这段低落期总是想起大学，想起初恋女友，可能这是我唯一拿得出手的回忆了\n按理来说，都分手了是应该表现得洒脱点，我搁这儿朝思暮想属实搞笑。不过反正没人知道，我不怕尴尬,我来细数一下我的神奇操作：\n-  WEB开发者模式从以前的空间留言可以看到她的QQ，一搜索发现头像是一张她近期的游客照，百度得知一浙江美术馆，看来生活过得还是很惬意的，不过穿着打扮已风格大变。而后觉得这些信息仍不足以满足我的好奇心，我便注册了个新的QQ号尝试加一下好友，没通过，罢了。\n- 一天我绞尽脑汁想起来我俩恋爱期间我有用过微博的，就安装微博上去一看，果然让我找到了一丝丝痕迹，从评论历史中可以看到她的账号，可是微博里一条关于她自己的内容都没有，只有头像疑似她本人被我保存了下来。\n\n哪怕我再怎么努力找寻她的踪迹，她始终是在过去的回忆里，我不该这样的，这样像一个偷窥狂，很病态。也许再过几年就好了。\n![](http://localhost:9001/c88cc47eacd047bab6c39c30c7bae198.jpg)\n\n\n\n###### 她的联系方式\n\n        QQ：1047552314\n        微博：幸得识卿桃花面从此 （阡陌多暖春，连起来好像是一句来自网络流传的标语）\n', NULL, '0');
INSERT INTO `blog` VALUES (0011, 2, 'CSS样式来源以及优先级', 'CSS的来源可以影响作用在元素上的优先级，元素最后的呈现样式是结合所有来源的CSS样式并判定优先级后的一个层叠值。', '0e226a4c280a4d60a9f69877c7a856d8.jpg', 1, 10, 'miatum', '2020-10-12 15:20:14', '#### 继承\n继承还是挺容易通过字面意思去理解的，即子元素会继承父元素的某些属性，常见的有font，如果给body定义了关于font的规则，此规则便会逐级被继承直到被覆盖。\n#### 层叠\n一个元素样式来源不是唯一的，如果冲突则根据优先级取交集，无冲突则取并集，而后依然有效的样式共同作用在元素上。\n#### 优先级\n###### 样式表的来源\n1、开发者写的样式表为**作者样式表**\n2、浏览器的默认样式或者浏览器允许用户可自定义样式，这些被称为用户代理样式\n优先级：作者样式>用户代理样式\n##### 行内样式\n行内样式没有选择器，直接作用于当前元素，我们可称之为最高优先级\n##### 选择器优先级\n一切遵循越精准越优先原则\n', NULL, '1');
INSERT INTO `blog` VALUES (0014, 1, '博客优化', '主要记录博客的优化过程，并发现新的值得优化的地方。', '1e2ce85f22d84176a6bfa88b84dc99a8.jpg', 1, 7, 'miatum', '2020-10-12 08:32:52', '# 管理界面\n1. ~~博客管理界面分类、标签显示的是ID~~   //blog实体类增加字段type_name，tag_name字段\n2. ~~博客管理界面双击进入编辑界面~~\n3. ~~类别、标签管理界面开启双击页面内编辑，舍弃点击编辑按钮弹窗编辑方式~~\n4. ~~table数据即时重载，新增或删除后不用刷新页面~~ 偶尔不会更新再次操作就行，原因不明\n5. 在没有选择时点击批量删除按钮后台会报SQL语法错误，建议前台先判断传值再让后台操作\n\n# 新增和编辑界面\n1. ~~阻止编辑和新增博客后页面的跳转~~\n2. ~~博客图片上传和保存问题~~\n3. 编辑和新增界面添加新增分类、标签的方法，最好优化成如果不存在改分类或标签自动新建\n4. ~~新增界面连续点击保存按钮，会增加多篇博客~~只有在博客id为undefined时才请求新增接口，在请求后回传ID赋给当前博客，再次点击提交按钮便不会请求新增接口而是请求更新接口\n\n\n# 整体设计\n1. 博客标签多选\n2. 进入后台管理没有身份验证\n3. ~~博客图片存储在项目静态资源路径下，开发和工作环境无法统一图片信息~~nginx配置独立的图片服务器\n\n# 前台界面\n1. ~~展示界面~~\n2. ~~查看单篇界面~~\n3. 页面滑动速度控制，监听鼠标滚轮事件和上下方向键\n4. PWA技术\n\n', NULL, '0');
INSERT INTO `blog` VALUES (0025, 2, 'Java接收图片的方法', '当前端传参内容为图片时，Java后台的处理方法。', '9538e345aaf94516ba332c80cf3d02d8.jpg', 1, 7, '小飞猪咯咯', '2020-10-13 22:16:31', '感谢这位博主。原文链接：[java接收图片的两种方法][1]\n太难了，感觉controller接收出问题了，保存的图片大小为0。\n果然采用第二种方法，会直接报空指针异常。\n终于用第二种方法成了，感觉这也是契合editor.md的，第一种方法估计只有理解了Java IO后才能去找出哪里出错了。\n```java\npublic String savePicByIo(HttpServletRequest request) throws IOException {\n        // 图片存储路径\n        String path = \"C:\\\\image\\\\factory\";\n        // 判断是否有路径\n        if (!new File(path).exists()) {\n            new File(path).mkdirs();\n        }\n        ServletInputStream inputStream = request.getInputStream();\n        String fileName = UUID.randomUUID().toString().replace(\"-\",\"\") + \".jpg\";\n        File tempFile = new File(path,fileName);\n        if (!tempFile.exists()) {\n            OutputStream os = new FileOutputStream(tempFile);\n            BufferedOutputStream bos = new BufferedOutputStream(os);\n            byte[] buf = new byte[1024];\n            int length;\n            length = inputStream.read(buf,0,buf.length);\n            while (length != -1) {\n                bos.write(buf, 0 , length);\n                length = inputStream.read(buf);\n            }\n            bos.close();\n            os.close();\n            inputStream.close();\n        }\n        return fileName;\n    }\n\n\n    public String savePicByFormData(MultipartFile file) throws IOException {\n\n        // 图片存储路径\n        String path = \"C:\\\\image\\\\factory\";\n        // 判断是否有路径\n        if (!new File(path).exists()) {\n            new File(path).mkdirs();\n        }\n        String fileName = UUID.randomUUID().toString().replace(\"-\",\"\") + \".jpg\";\n        File tempFile = new File(path,fileName);\n        if (!tempFile.exists()) {\n            tempFile.createNewFile();\n        }\n        file.transferTo(tempFile);\n        return fileName;\n    }\n```\n\n[1]: https://www.cnblogs.com/flypig666/p/12488556.html \"java接收图片的两种方法\"', NULL, '1');
INSERT INTO `blog` VALUES (0028, 2, 'CSS属性object-fit', 'css3中object-fit:cover的使用，可完全填充容器且显示图片居中的部分', '61485d7071ed4bf2ad59ca8f997b7a41.jpg', 1, 10, 'miatum', '2020-10-16 16:05:51', '**object-fit**有5个值，分别是：\n- fill: 中文释义“填充”。默认值。替换内容拉伸填满整个content box, 不保证保持原有的比例。\n- contain: 中文释义“包含”。保持原有尺寸比例。保证替换内容尺寸一定可以在容器里面放得下。因此，此参数可能会在容器内留下空白。\n- cover: 中文释义“覆盖”。保持原有尺寸比例。保证替换内容尺寸一定大于容器尺寸，宽度和高度至少有一个和容器一致。因此，此参数可能会让替换内容（如图片）部分区域不可见。\n- none: 中文释义“无”。保持原有尺寸比例。同时保持替换内容原始尺寸大小。\n- scale-down: 中文释义“降低”。就好像依次设置了none或contain, 最终呈现的是尺寸比较小的那个。\n- 这里的容器指的的是应用.work-img样式的容器\n\n下面是演示cover的代码：\n```css\n.work-img img{\n    object-fit: cover;\n    width: 100%;\n    height: 100%;\n}\n```\nPS：通过background方式显示图片需要测试', NULL, '1');
INSERT INTO `blog` VALUES (0029, 2, '父元素不可见，子元素可见', 'visibility属性的使用，而非常用的display。', 'e5f31b12da844acf92aa2dacdf5d6cd9.jpg', 1, 10, 'miatum', '2020-10-17 14:48:35', '###### display\n是不是一看见标题的问题就立马想到了用`display`来实现，像：\n```html\n<div style=\"display:none;\">\n	<div style=\"display:block\"></div>\n</div>\n```\n然而结果却并不会如你所愿，子元素`<div>`并不会显示，`display：none`是会被强制继承的。即使子元素`<div>`不写行内样式`display：block`，`<div>`标签的display的初始值就是block。\n此时就要理解`display: none`的实际效果了，设置了此效果的DOM元素是不会被浏览器渲染的，即不存在。\n###### visibility\n而要达到父元素可见，子元素不可见的效果，则需要用到`visibility`属性。\n```html\n<div style=\"visibility:hidden;\">\n	<div style=\"visibility:visible\"></div>\n</div>\n```\n设置`visibility: hidden`的元素是会被浏览器渲染的,只是针对用户不可见.', NULL, '1');
INSERT INTO `blog` VALUES (0030, 2, 'Spring boot程序部署注意事项', 'Spring boot官方推荐用Jar包方式部署，因为其内置了tomcat的；如果需要用外置tomcat+war包形式部署，启动类需要继承SpringBootServletInitiailzer并重写其configure()方法。', '82dc3e0fced94aa4a677a1713135cfa4.jpg', 1, 23, 'miatum', '2020-10-18 10:17:40', '### Jar包方式部署\n使用`maven`打包插件打包后，控制台切换到jar包目录，以`java -jar projectname.jar`运行。\n### war包方式部署\n在打包之前，确认启动类继承SpringBootServletInitiailzer并已重写其configure()方法。\n```java\n@SpringBootApplication\npublic class FileuploadApplication extends SpringBootServletInitializer {\n    public static void main(String[] args) {\n        SpringApplication.run(FileuploadApplication.class, args);\n    }\n    @Override\n    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {\n        return super.configure(builder);\n    }\n}\n```\n而后按照常规web项目放到tomcat/webapps下启动tomcat即可。', NULL, '1');
INSERT INTO `blog` VALUES (0031, 2, '匈牙利算法', '计算最大匹配数', 'a8ea78be01ff4145be3b8a971d85034a.jpg', 1, 41, 'miatum', '2020-10-27 18:51:48', '###### 题目描述：\n若两个正整数的和为素数，则这两个正整数称之为“素数伴侣”，如2和5、6和13，它们能应用于通信加密。现在密码学会请你设计一个程序，从已有的N（N为偶数）个正整数中挑选出若干对组成“素数伴侣”，挑选方案多种多样，例如有4个正整数：2，5，6，13，如果将5和6分为一组中只能得到一组“素数伴侣”，而将2和5、6和13编组将得到两组“素数伴侣”，能组成“素数伴侣”最多的方案称为“最佳方案”，当然密码学会希望你寻找出“最佳方案”。\n输入:\n有一个正偶数N（N≤100），表示待挑选的自然数的个数。后面给出具体的数字，范围为[2,30000]。\n输出:\n输出一个整数K，表示你求得的“最佳方案”组成“素数伴侣”的对数。\n###### 解题思路：\n题目限定了输入数为[2,30000]，那么匹配成功后的素数一定是大于2的，大于2的素数有一个特性即都为奇数，奇数=偶数+奇数，于是输入数组可以拆分两个数组，一个奇数数组一个偶数数组，此时不难发现匈牙利算法适用。\n###### 匈牙利算法简介：\n设G(V, E)是一个无向图。如顶点集V可分割为两个互不相交的子集V~1~V~2~，选择这样的子集中边数最大的子集称为图的最大匹配问题（maximal matching problem)。\n如果一个匹配中， 且匹配数|V~1~| <= |V~2~| ，则称此匹配为完全匹配，也称作完备匹配。特别的当|V~1~| = |V~2~|称为完美匹配。 \n###### 代码实现：\n```\npackage algorithm;\n\nimport java.util.*;\n\n/**\n * @Description \n * @ClassName Hungary\n * @Author Miatum\n * @date 2021.04.07 16:43\n */\npublic class Hungary {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = 0;\n        List<Integer> odd = new ArrayList<Integer>();\n        List<Integer> even = new ArrayList<Integer>();\n        List<Integer> result = new ArrayList<Integer>();\n        while (in.hasNextInt()) {\n            if (n == 0) {\n                n = in.nextInt();\n            } else {\n                n--;\n                int nextInt = in.nextInt();\n                if (nextInt % 2 == 0){\n                    even.add(nextInt);\n                } else {\n                    odd.add(nextInt);\n                }\n                if (n == 0) {\n                    result.add(getResult(odd, even));\n                    odd.clear();\n                    even.clear();\n                }\n            }\n        }\n        for (Integer i : result) {\n            System.out.println(i);\n        }\n    }\n    /**\n     * @Description\n     * @Param used[] 偶数是否已被匹配，0 - 未匹配， 1 - 已匹配; evensMatch[] 偶数匹配奇数结果\n     * @return\n     * @Author Miatum\n     * @Date 2021.04.12 11:28\n     **/\n    public static int getResult(List<Integer> odd, List<Integer> even) {\n        int result = 0;\n        int[] evensMatch = new int[even.size()];\n        for (int i = 0; i < odd.size(); i++) {\n            int[] used = new int[even.size()];\n            if (fetch(odd.get(i), even, used, evensMatch)) {\n                result++;\n            }\n        }\n        return result;\n    }\n    public static boolean fetch(int x, List<Integer> even, int[] used, int[] evensMatch) {\n        for (int i = 0; i< even.size(); i++) {\n            if (isPrimary(x + even.get(i)) && used[i] == 0) {\n                used[i] = 1;\n                if (evensMatch[i] == 0 || fetch(evensMatch[i], even, used, evensMatch)) {\n                    evensMatch[i] = x;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    public static boolean isPrimary(int num) {\n        boolean isPrimary = true;\n        if (num != 2) {\n            for (int i = 2; i < num; i++) {\n                if (num % i == 0) {\n                    isPrimary = false;\n                    break;\n                }\n            }\n        }\n        return isPrimary;\n    }\n}\n\n\n```\n', NULL, '1');
INSERT INTO `blog` VALUES (0050, 2, '候鸟', '四季变换，候鸟南飞', 'ec6ab929a2c241c298a27f008674579c.jpg', 37, 25, '五月天', '2021-02-23 05:22:53', '::: hljs-center\n\n###### 冰箱上有字条\n###### 桌上有菜\n###### 电锅里面有饭\n###### 没有人在\n###### 电话里的独白\n###### 还在等待\n###### 一个人的表情\n###### 怎么安排\n###### 我也早有预感\n###### 一起风满\n###### 生命的窗忘了关\n###### 吹进意外\n###### 旅途上的愉快\n###### 划过一半\n###### 南方又在呼唤\n###### 当我醒来\n###### 飞过那片茫茫人海\n###### 下个路口直走或转弯\n###### 长大太慢老得太快\n###### 等得太久\n###### 结果太难猜\n###### 我的故事被风吹散\n###### 我的明天我从不期待\n###### 所以现在我只想要\n###### 寻找一丝最后的温暖\n###### 包厢里的狂欢\n###### 曲终人散\n###### 长夜里的空白\n###### 消化不完\n###### 灵魂总是要贪\n###### 片刻灿烂\n###### 那双唇的孤单\n###### 变得野蛮\n###### 那陌生的阳光\n###### 照在床单\n###### 昨夜发生的事\n###### 不想再猜\n###### 而枕边的人啊\n###### 一直在换\n###### 每一次都以为\n###### 到了终站\n###### 飞过那片茫茫人海\n###### 下个路口直走或转弯\n###### 长大太慢老得太快\n###### 等得太久\n###### 结果太难猜\n###### 我的故事被风吹散\n###### 我的明天我从不期待\n###### 所以现在我只想要\n###### 寻找一丝最后的温暖\n\n\n:::\n', NULL, '1');
INSERT INTO `blog` VALUES (0051, 2, '发掘 The Dig', '纪实故事', '8b649c3b745a44069afc3a4d28b2bafb.jpg', 35, 26, '西蒙·斯通', '2021-01-28 16:00:00', '##### 由难到易\n人是复杂的生命体，除了身体机能还有情感，生活中种种的挑战诸多的不如意带来的消极情绪很难有释放的机会。古人聪明，知道防微杜渐，从源头根除，所谓求其上而得其中，如果事先经历了更大的挫折更困难的挑战，那么往后将面对的都不会是问题。\n道理衍变到现在，变成了若是厌倦了琐碎生活就想想战争时期平民的苦难，就会珍惜当下得来不易的和平生活。那么，问题来了，战争时期的人们是怎么靠这种理念撑过来的呢？比战争更可怖的是什么呢？比战争时期的生活更苦难的生活是什么样的呢？想且想不出，先辈们有怎么会经历过呢。\n##### 更高的境界\n', 'The.Dig.2021.HDR.2160p.NF.WEBRip.DDP5.1.Atmos.x265-NoGRP/The.Dig.2021.HDR.2160p.NF.WEBRip.DDP5.1.Atmos.x265-NoGRP.mkv', '1');
INSERT INTO `blog` VALUES (0052, 2, '波斯语课 Persischstunden', '二战时时期的犹太人，通过教授德国军官波斯语而获得逃生机会。', 'a1cd38101a624b58be97737e1f400c98.jpg', 35, 26, '瓦迪姆·佩尔曼', '2020-09-23 16:00:00', '##### 对立面\n小时候看电影，总要对电影里的角色分阵营，非好即坏，喜好厌坏。现在长大了，心思变复杂了，看问题反而没那么透彻了。不过看完《波斯语课》，想着按小时候的方式再来划分一次角色的阵营。\n\n###### 角色列表\n- 主人公雷扎：\n- 以书换面包的犹太人\n- 上尉：\n- 指挥官\n- 女下士1\n- 女下士2\n- 男下士1\n- 男下士2\n', NULL, '1');
INSERT INTO `blog` VALUES (0053, 2, '跨域问题', '前后端分离情况下，前端请求后端接口存在跨域问题', '', 1, 11, 'miatum', '2021-02-23 15:27:39', '###### 什么是跨域：\n跨源资源共享 (CORS) （或通俗地译为跨域资源共享）是一种基于HTTP 头的机制，该机制通过允许服务器标示除了它自己以外的其它origin（域，协议和端口），这样浏览器可以访问加载这些资源。跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的\"预检\"请求。在预检中，浏览器发送的头中标示有HTTP方法和真实请求中会用到的头。\n\n跨源HTTP请求的一个例子：运行在 http://domain-a.com 的JavaScript代码使用XMLHttpRequest来发起一个到 https://domain-b.com/data.json 的请求。\n\n出于安全性，浏览器限制脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非响应报文包含了正确CORS响应头。\n\n###### 哪些情况会导致跨域：\n- IP不同\n- 端口不同\n- IP相同端口不同\n- IP不同端口相同\n###### 跨域问题的解决办法：\n以nginx部署vue项目为例，如果开发环境时的proxy配置导致axios写法如下：\n```\naxios.get(\'api/selectAllBlog\').then(response => {\n    }).catch(error => {\n      console.log(error)\n    })\n\n```\n那么在打包后部署时需要在nginx.conf加入以下内容：\n```\n// \'/api/\'，\'http://127.0.0.1:8081/\'根据实际情况填写\nlocation /api/ {\n    proxy_pass   http://127.0.0.1:8081/;\n}\n\n```\n\n\n', NULL, '1');
INSERT INTO `blog` VALUES (0054, 0, '九寨沟之旅', '2021年3月,为期一个月的九寨沟出差之旅', '', 8, 33, 'miatum ', '2021-03-02 12:19:20', '### 感受\n  虽然目前无法避免工作出差,但是去到一些地方,看到不同的风景人情,不失为丰富人生的见识.想走得远,很难;想看得多,亦很难.尤其人们总是对生活怀抱着美好的期望,现实难免会有落差,怎么说服自己去接受去苦中作乐呢?\n### 途中见闻\n  早早出发,赶了1小时的地铁,和同事会和出发,已是早上9点.车内我们三人,有一搭没一搭的聊着我们8090的童年,抓螃蟹钓鱼,无一不美好,车窗外的阳光一直照耀着我们,指引着我们一路向北.慢慢,成都平原被我们甩在身后,傍着我们的是连绵不绝的山峰,不高却显得那么威严;道路旁的岷江是我们的路标,我们像是去追逐它的源头而非奔着某个明确的目的地.\n  今年的春天来得贴别早,原以为是上天为抚恤经过一年疫情折磨的人们,迫不及待的想温暖可怜的世众,不过那远方雪白的山头打消了我的臆想.原来,春暖花开有时,高岭积雪亦有时.我小憩了一会,醒来是下午2点左右,我们在路边的一个饭店停下,打开车门,贯穿整个山谷的风肆无忌惮地吹拂着我,带着冷冽.我们透过饭馆店璃墙面,向里打探着,老板娘看见我们便热情的招呼我们进去.饭店内还存留着过年的气息,有几人围坐打着麻将,另一边烧着炉火,煮着可乐红枣枸杞,炉边摆放着糖果干粮,我感觉到暖和,我们像是来串门的.\n### 一个月\n  下午6点，我们到了住的旅馆，因为是淡季，厨房并未开张，我们吃了一碗泡面，互相熟络熟络便去睡下。其实，工作起来，一个月过得挺快的，无论是泡在机房的那几天，还是跑前跑后的那几天，或是无所事事的那几天。这里，天多是晴朗的，当然也洒过大雪，下过小雨，不知道是水份都让九寨沟的湖泊吸收完了还是怎么回事，干燥。日子慢慢过着，我认识到，这里不是异国他乡，只是气候有点差异，我还是在川内，常去买烟的小卖部的老板，旅馆老板，做饭的师傅，都是同乡，这个世界很大，而我只是朝着未知迈出了一小步，便自以为自己探索了奇境。\n', NULL, '0');
INSERT INTO `blog` VALUES (0055, 2, '华为服务器H22H-05', '服务器系统安装，网络配置', '', 43, 30, 'miatum', '2021-03-08 12:00:55', '### 物理机系统安装\n**一般服务器不会直接安装操作系统，为了更好地利用服务器的高性能高存储，会将服务器CPU、内存、存储划分给若干个虚拟机，以虚拟机运行操作系统。**\n1、服务器iBMC网口直连PC,PC配置IP为192.168.2.x(0=<x && x <= 255, x != 100),浏览器访问192.168.2.100，默认用户名Admin，密码Admin@9000。\n**步骤**\n一、配置磁盘阵列（device manager -> ）\n如果有且只有一块SDD，即明显的系统预留盘，则将此硬盘作为RAID 0模式建立磁盘阵列。\n其余硬盘中相同大小的机械硬盘，则建议视硬盘数量选择RAID 1（2块），RAID 5（大于2块），关于磁盘阵列的介绍请往下翻。\n![aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80ODU0ODk5LTRmNmJlZDIyN2JlODFiYjkucG5n.png](http://localhost:9001/f69bdc0b936242f2ba23b464da43e8c2.png)\n![aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80ODU0ODk5LWFkNjA1ZTVlN2UyNzMzMzMucG5n.png](http://localhost:9001/c401b663b3524dbfaad9b4a5146a578a.png)\n![aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80ODU0ODk5LTAzMzUwOWE3YTFmMzBiNzUucG5n.png](http://localhost:9001/239ede3f231a43ffbd0809c118f60088.png)\n![aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80ODU0ODk5LWU4ZTNjYTFhZWE1Yjk1ZDgucG5n.png](http://localhost:9001/ebb26b50858a4aabadb6845d9d44ff0e.png)\n\n![aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80ODU0ODk5LWIzY2JmM2JmMzcwMWVkZTQucG5n.png](http://localhost:9001/ae8be1966220465ea11f80bfacd37042.png)\n![aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80ODU0ODk5LTU4YWVhNTAyZDQ0N2NjOTYucG5n.png](http://localhost:9001/8a3ab07b526242c99b4bd05c35c5b4e5.png)\n![aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80ODU0ODk5LTI1YjIwNWI0NDVlMWYxYTQucG5n.png](http://localhost:9001/cbd40a4e0a1b41e4b5cf232e56d14409.png)\n![aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80ODU0ODk5LWQ5YTNjNjFiOWJiODEwMjEucG5n.png](http://localhost:9001/dc33e6bc2a744cc8bb554e7b7970c482.png)\n![aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80ODU0ODk5LWNhZjc4OWJkMDRkOWU2MTkucG5n.png](http://localhost:9001/1b66588bdac14ce08db7840ab59b76b0.png)\n![aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80ODU0ODk5LTE4MjJlMTBhMjdjOTM2ZDcucG5n.png](http://localhost:9001/2a5776ddac724ebab7ebacf57214e61a.png)\n![aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80ODU0ODk5LWI0NmFjOWFmMzNhNjEyZGYucG5n.png](http://localhost:9001/ea1a4d3ef14f48f1be13b2e2cc503232.png)\n![aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80ODU0ODk5LTg1N2I3YzRmMmQ3NWE5OGQucG5n.png](http://localhost:9001/d575083e20034447a6a366cc1e16b299.png)\n二、挂载镜像\n通过web端远程管理界面挂载镜像文件，在boot manager中选择virtual DVD-ROOM，开始安装。\n2、启动盘，将镜像通过Ultra ISO刻录到Ｕ盘中，以此进行系统安装。\n**步骤**\n一、同１进行磁盘阵列配置。\n二、进入bootmanager，设置从U盘启动，重启进行系统安装程序。\n\n### 磁盘阵列简介\nRAID技术主要包含RAID 0~5等数个规范，它们的侧重点各不相同，常见的规范有如下几种：\nRAID 0\n\n此RAID级别组合了两个或更多硬盘，组合方式是用户数据被分割成多个可管理单元。这些单元被分割到RAID 0阵列的不同驱动器中。就像是货运公司运货一样，以前只有一辆车运输货物，现在有了更多的汽车把货物分开传送，效率自然就会提高很多。但是，RAID 0阵列中未存储冗余信息，这就是说，其中一个硬盘出现故障后，所有数据都会丢失。因此，安全要求较高的服务器一般不使用RAID 0。\nRAID 1\n\n在RAID 1系统中，相同的数据被存储在两个硬盘上（100%冗余）。当一个磁盘驱动器发生故障时，在另一个磁盘上可立即获得数据，从而无损数据完整性。就像我们打印文件一样，为了保证数据不会丢失，通常会多打印一份保存下来。另外，当原始数据繁忙时，系统还可以从备份中读取数据，因此RAID 1可以提高读取性能。可以说RAID1即提高了效率也提高了系统的安全性。\nRAID 2\n\n将数据一份份地分布于不同的硬盘上，每一份的单位为位或字节，并使用一种专门的编码技术来提供错误检查及恢复。RAID 2技术实施复杂，因此目前很少使用，因此不做过多的介绍。\nRAID 3\n\n同RAID 2非常类似，都是将数据拆分并分布于不同的硬盘上，区别在于：RAID 3使用简单的奇偶校验，并单独使用一块磁盘存放奇偶校验信息。如果其中的一块数据磁盘失效，奇偶盘及其数据盘可以重新计算出损失的数据并还原到磁盘上；RAID 3对于大量的连续数据可提供稳定的传输率，但对于随机数据来说，奇偶盘会成为写操作的瓶颈。\nRAID 4\n\nRAID 4与RAID 0非常相似，数据分割在各磁盘之间。不同的是RAID 4使用一块硬盘作为奇偶校验盘，当其中一个数据盘发生故障时，丢失的数据通过剩下的有效数据盘以及奇偶校验信息计算后存取。这种备份数据的方法好比我们在打印文件的同时，另外给打印过的文件作个清单，当其中的某份文件丢失时，可以按照清单的记录来恢复文件。此方法比RAID 1中的备份方法要复杂一些，而且此技术的不足点是每次写操作都需要访问奇偶盘，这时奇偶校验盘会成为写操作的瓶颈，因此RAID 4在商业环境中的应用也很少。\nRAID 5\n\n与RAID 4的读写磁盘过程相似，每次写操作都需要访问奇偶盘，但因为RAID 5磁盘阵列中的奇偶校验数据分割在各磁盘之中。这样一来当同时有多个读写操作时，每个操作会被平均分配到不同的磁盘上，这样就提供了更加平衡的吞吐量。RAID 5与RAID 4的安全级别相同：其中一个磁盘发生故障时，所有的数据完全可用。丢失的数据通过有效数据以及奇偶校验信息计算得出。\nRAID 0及RAID 1由于实现的成本较低主要适用于PC等家用电脑中；RAID 2较少使用由于实现技术复杂，所以目前很少用到；RAID 3及RAID 4适用于大型服务器及影像系统中；RAID 5多用于金融机构等与大型数据处理相关的企业中，其他如RAID 6，RAID 7，乃至RAID 10等，都是厂商各自研发，并无一致的标准。\n我们常见的主板自带的阵列芯片或阵列卡能支持的模式有：RAID 0、RAID 1、RAID 0＋1。\n\nRAID 0是无数据冗余的存储空间条带化，它将所有硬盘构成一个磁盘阵列，可以同时对多个硬盘做读写动作，但是不具备备份及容错能力，具有成本低、读写性能极高、存储空间利用率高等特点，在理论上可以提高磁盘子系统的性能。\nRAID 1是两块硬盘数据完全镜像，可以提高磁盘子系统的安全性，技术简单，管理方便，读写性能均好。但它无法扩展（单块硬盘容量），数据空间浪费大，严格意义上说，不应称之为“阵列”。\nRAID 0＋1综合了RAID 0和RAID 1的特点，独立磁盘配置成RAID 0，两套完整的RAID 0互相镜像。它的读写性能出色，安全性高，但构建阵列的成本投入大，数据空间利用率低，不能称之为经济高效的方案。', NULL, '1');
INSERT INTO `blog` VALUES (0056, 2, 'Oracle数据库的备份与还原', 'expdp, impdp命令的使用', '', 1, 32, 'miatum', '2021-03-08 12:22:14', '### Oracle用户\nOracle的存储结构为:全局数据库 -> 用户 -> 表,即单实例Oracle数据库中只有一个数据库,表都是和用户绑定的,这点概念和MySQL,SQL server不同\n### 备份\n1 建立逻辑导出路径,建立物理路径,并授权给用户(SQL plus)\n连接数据库\n```\ncreate directory dumpdir as \'C:\\backfolder\';\n\n```\n\n在C盘下建立backfolder文件夹\n```\ngrant read, write on directory dumpdir to username;\n```\n\n2 执行导出语句(cmd / terminal)\n```\nexpdp username/password@ip/sid schemas=username directory=dumpdir dumpfile=expdp.dmp logfile=expdp.log\n\n```\n上面语句,即导出位于ip的实例名为sid的用户username下所有表到C:\\backfolder下的expdp.dmp文件中,导出日志文件为expdp.log\n### 还原\n1 建立表空间(SQL plus)\n```\ncreate tablespace impdpspace datafile \'C:\\backfolder\\expdp.dmp\' size 1024M autoextend on next 200M maxsize unlimited logging extent management local segment space management auto;\n\n```\n\n2 建立用户,指定用户表空间并授权(SQL plus)\n```\n// 建立用户,指定表空间\ncreate user username identified by password default tablespace=impdpspace;\n// 用户授权\ngrant create view, alter session, connect, resource, unlimited tablespace to username;\ngrant imp_full_database to username;\n\n```\n3 创建恢复路径并授权(SQL plus)\n```\ncreate or replace directory dumpdir as \'C:\\backfolder\';\ngrant read, write on directory to username;\n\n```\n4 执行导入语句\n```\nimpdp username/password directory=dumpdir dumpfile=expdp.dmp;\n\n```\n', NULL, '0');
INSERT INTO `blog` VALUES (0057, 2, '送你一朵小红花', '两个抗癌家庭，两组生活轨迹。影片讲述了一个温情的现实故事，思考和直面了每一个普通人都会面临的终极问题——想象死亡随时可能到来，我们唯一要做的就是爱和珍惜。', '46e060f0a8284e8392b2221661b5e523.jpg', 35, 33, '韩延', '2021-03-08 13:22:38', '', '送你一朵小红花.4K HDR10高码.A.Little.Red.Flower.2020.WEB-DL.2160p.H265.10bits.HDR10.DDP 5.1-PTHweb.mp4', '1');
INSERT INTO `blog` VALUES (0058, 2, '同学麦娜丝', '', 'f7d6c07db24b4cb19e8577a370a7aab1.jpg', 35, 33, '黄信尧', '2021-03-09 08:36:33', '', 'Classmates.Minus.2020.NF.WEB-DL.1080p.x264.DDP5.1-PTHweb/Classmates.Minus.2020.NF.WEB-DL.1080p.x264.DDP5.1-PTHweb.mkv', '1');
INSERT INTO `blog` VALUES (0059, 1, '纪念胡春瑞', '周鸣秋，每一次你想要堕落的时候，来这里看看。', '', 8, 35, 'miatum', '2021-03-11 02:49:57', '我一直害怕提及这件事，这件事是烙印，是我避无可避的，带着恐惧自责，无论什么原因，一个人的逝去不应该就这样归于尘土，这不是人生的终点。\n### 睡不醒睡不着的一天\n2021年1月4日上午，今天是元旦假期后的第一个工作日，熟睡的我被一阵阵的拍门声吵醒，听着门外的嘈杂，想起最近网络上泛滥中介公司跑路的新闻，我以为这个出租屋房间不再是我的落脚点了，有点慌乱，看着房间里残留着昨天的外卖垃圾，我竟然还顾及着门外‘业主’的感受，急忙收拾到阳台，手忙脚乱还打翻了一个外卖盒，洒了一地的汤汁。这时，我开始释怀了，都颓丧到这地步了，为什么还要去在意这些，我走到门前，深呼吸了一口气打开房门，看着门外的人们，他们有人拿着工具撬着我隔壁房间的门，有人打着电话有一搭没一搭的聊着，有人互相商量着什么。开始他们没有注意到我，”你们是？“，我小心的问到。”你是这里的租客吗？你最近有看到住这个房间的人吗？“，他们没有回答我的问题，而是指着我隔壁房间的门反问我。我说我没见过，他们便急忙让我问其他室友，我还是没有意识到发生了什么，便按他们说在租客微信群里问室友们。可是我没法描述清楚，因为室友的名字我一个都叫不出来，我第一次清楚你的名字，还是从你的同事口中得知，”古月胡，春天的春，瑞雪兆丰年的瑞“。其他的室友们回消息说看到你昨晚有在拖地，我把回信给现场的人看，我才注意到现场的人里，有物业有保安有民警，我心里有一丝不安，比起遭遇中介跑路的荒唐，跟让我琢磨不透。\n”草！“半蹲着透过钥匙孔查看房间内情况的一个小伙子大喊一声，起身便开始踹门，一下又以下，声音格外的大，不知道是我身体的隔音效果太差，还是引发共振的原因，仿佛声音在我心脏旁响起。”嘭“的一声随着门被踹开撞到房间里墙壁，在场所有人都惊呆了，你的身体就那样悬在房间里的晾衣杆上，背对着我们。你的一个同事开始嚎啕大哭，进去抚摸你的手，而我这个胆小鬼不敢再多看一眼便去到客厅。\n这一天后面发生的事情我已记得不太清，我只记得我去到客厅觉得特别冷，去楼下买了包烟，即使点着了烟身体还是忍不住发抖，再回到1302时，已经陆陆续续到了很多人，中介公司的人，法医，其他的室友。你的遗体被搬走后，你住过的房间就被封了起来，我们其他人都在收拾东西搬家。\n### 短暂漫长的一生\n2021年3月11日上午，事隔两个多月，我终于鼓起勇气将你和这世界的告别仪式记录下来。说实话我确实是有被吓到，这期间我努力去找工作、努力表现得很活泼开朗，让自己累一点，晚上才能睡得着。以前我总觉得独处安静无人打扰，现在我只觉得后背发凉，睡觉也是看着涛妹的炉石直播入睡的。虽然我的存在并不是影响你坐选择的因素，但是事后我仔细想过，3号那天停电时，我敲开了你的房间门，我们能聊上几句，说不定你就改变主意了呢。\n我知道人生的意义不在于长短，你所经历的困难我无法感同身受，但我还是决定了。往后，我要学做一个太阳，勇于散发自己的光芒，无论透过阴霾的，还是明亮照人的，打在我身边的每一个人身上，去感受他们的开心，体会他们的难过。说的有点像一个圣人，但我会努力的。\n胡春瑞，谢谢你让我感悟很多，也很遗憾没能和你成为好朋友。', NULL, '0');
INSERT INTO `blog` VALUES (0060, 0, '黑苹果安装', '', '', 1, 34, 'miatum', '2021-03-23 12:23:38', '## VMware® Workstation 16 Pro 安装 macOS Big Sur\n### 解除限制\n首先，我们要明白VM ware是不支持安装mac OS镜像的，所以需要用到三方软件Unloacker解除这个限制。\n### 镜像获取\n在网上倒是很容易查询到mac OS镜像的下载地址，但是需要注意的一个点是，镜像格式会有很多种，如dmg、ISO、vmdk等。所以你需要理解不同格式之间的区别，以及哪个可用于VM ware安装虚拟机。\n**dmg**\ndmg文件可在Mac系统上直接运行加载，所以dmg的镜像是给已安装较低版本Mac OS的电脑升级使用的。\n**ISO**\nISO光盘镜像文件，镜像文件是一种光盘文件信息的完整拷贝文件。当然，ISO文件也可由刻录软件或镜像文件制作工具创建，可在Windows上通过虚拟光驱运行。\n**vmdk**\nVMDK（VMWare Virtual Machine Disk Format）是虚拟机VMware创建的虚拟硬盘格式，文件存在于VMware文件系统中，被称为VMFS（虚拟机文件系统）。VMWare可直接打开vmdk文件，读取虚拟硬盘中的虚拟机操作系统。', NULL, '0');
INSERT INTO `blog` VALUES (0061, 2, '尘埃', '', '', 37, 35, '王菲', '2021-03-24 13:17:42', '1', NULL, '0');
INSERT INTO `blog` VALUES (0062, 2, '红色跑车', '', '', 37, 35, '太极乐队', '2021-03-24 14:45:18', '<p>::: hljs-center</p>\n<p>作词 : 因葵</p>\n<p>红色的跑车像是带着神秘</p>\n<p>零星的街灯充满乐与悲</p>\n<p>银色的烟盒尽是爱是游戏</p>\n<p>拿起香烟你便会筋竭力疲</p>\n<p>红色的跑车是诱惑游戏</p>\n<p>唇膏的色彩性感带着痛悲</p>\n<p>桃色的肌肤是诱惑原是你</p>\n<p>拿起香烟这段插曲更迷离</p>\n<p>香槟酒樽碎片遍地</p>\n<p>身边的她亦昏醉</p>\n<p>Let&#39;s go to highway 闪出眼泪</p>\n<p>像钻石茫茫然抹去扰虑</p>\n<p>Let&#39;s go to highway baby</p>\n<p>留下这打火机在车里</p>\n<p>红色的跑车像是带着神秘</p>\n<p>零星的街灯充满乐与悲</p>\n<p>银色的烟盒尽是爱是游戏</p>\n<p>拿起香烟你便会筋竭力疲</p>\n<p>红色的跑车是诱惑游戏</p>\n<p>唇膏的色彩性感带着痛悲</p>\n<p>桃色的肌肤是诱惑原是你</p>\n<p>拿起香烟这段插曲更迷离</p>\n<p>香槟酒樽碎片遍地</p>\n<p>身边的她亦昏醉</p>\n<p>Let&#39;s go to highway 闪出眼泪</p>\n<p>像钻石茫茫然抹去扰虑</p>\n<p>Let&#39;s go to highway baby</p>\n<p>留下这打火机在车里</p>\n<p>Let&#39;s go to highway 闪出眼泪</p>\n<p>像钻石茫茫然抹去扰虑</p>\n<p>Let&#39;s go to highway baby</p>\n<p>留下这打火机在车里</p>\n<p>:::</p>\n', NULL, '1');
INSERT INTO `blog` VALUES (0063, 2, 'IDEA注释模板', '', 'e13c803cbd6b4650a5333444904a779e.png', 1, 37, 'miautm', '2021-03-25 03:22:33', '### 文件头注释\nfile -> setting -> Editor -> File and code Templates\n修改右侧File选项卡下Class内容，如下：\n![image.png](http://localhost:9001/180c1717120d4fb79954d114050c4254.png)\n```\n#if (${PACKAGE_NAME} && ${PACKAGE_NAME} != \"\")package ${PACKAGE_NAME};#end\n#parse(\"File Header.java\")\n/**\n * @Description \n * @ClassName ${NAME}\n * @Author Miatum\n * @date ${YEAR}.${MONTH}.${DAY} ${HOUR}:${MINUTE}\n */\npublic class ${NAME} {\n}\n\n```\n### 方法注释 \nfile -> setting -> Editor -> Live Templates\n点击右侧+号，新增Template group\n![image.png](http://localhost:9001/d68746f157974f468b894db9026b01be.png)\n选中刚刚新建的group，点击+号，新建Live Template\nAbbreviation: 调用注释命令\nDescription：注释说明\nTemplate text改为如下内容: \n```\n/**\n * @Description \n * @Param $param$\n * @return $return$\n * @Author Miatum\n * @Date $date$ $time$\n **/\n\n```\n\n![image.png](http://localhost:9001/adae6fb762bc4f79a5a2f26bee9a60f3.png)\n点击Edit variables，修改变量表达式值如下：\n![image.png](http://localhost:9001/bedf479097c3454b9ba4f6eaeb82d6c4.png)', NULL, '1');
INSERT INTO `blog` VALUES (0064, 2, 'FFmpge视频转码', '', '46e895b79341427d81f8e47c824117df.png', 1, 38, 'miatum', '2021-03-25 09:07:35', '### 使用场景\n为什么会有这个需求，因为HTML的video标签只支持三种视频格式，即ogg、MP4、webm。但这三种格式并不是网络中常见的视频格式，如MKV等。虽然严格意义上讲MKV并不是视频格式，他只是一个视频的容器。但是在拿到MKV源文件后，如何在网页上播放呢？这时就需要用到FFmpge将其进行转码。\n### FFmpge的使用方法\n###### 服务器转码\n引入依赖：\n```\n        <dependency>\n            <groupId>org.bytedeco</groupId>\n            <artifactId>javacv</artifactId>\n            <version>1.5</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.bytedeco</groupId>\n            <artifactId>javacv-platform</artifactId>\n            <version>1.5</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.bytedeco</groupId>\n            <artifactId>javacpp</artifactId>\n            <version>1.5</version>\n        </dependency>\n\n        <dependency>\n            <groupId>org.bytedeco.javacpp-presets</groupId>\n            <artifactId>opencv-platform</artifactId>\n            <version>4.0.1-1.4.4</version>\n        </dependency>\n\n```\n调用FFmpge进行转码：\n```\n     /**\n     * @Description 将视频文件转码成MP4格式\n     * @Param file 视频文件\n     * @return String 转码后MP4格式视频文件地址\n     * @Author Miatum\n     * @Date 2021.03.25 11:48\n     **/\n    public String convertToMP4(File file) {\n        FFmpegFrameGrabber grabber = new FFmpegFrameGrabber(file);\n        String fileName = null;\n        Frame captured_frame = null;\n        FFmpegFrameRecorder recorder = null;\n        try {\n            grabber.start();\n            fileName = file.getAbsolutePath() + \"_.mp4\";\n            recorder = new FFmpegFrameRecorder(fileName, grabber.getImageWidth(), grabber.getImageHeight(), grabber.getAudioChannels());\n            recorder.setVideoCodec(avcodec.AV_CODEC_ID_H264);\n            recorder.setFormat(\"mp4\");\n            recorder.setFrameRate(grabber.getFrameRate());\n            recorder.setSampleRate(grabber.getSampleRate());\n            recorder.setAudioChannels(grabber.getAudioChannels());\n            recorder.setFrameRate(grabber.getFrameRate());\n            recorder.start();\n            while ((captured_frame = grabber.grabFrame()) != null) {\n                try {\n                    recorder.setTimestamp(grabber.getTimestamp());\n                    recorder.record(captured_frame);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            recorder.stop();\n            recorder.release();\n            grabber.stop();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return fileName;\n    }\n\n```\n需要注意的是，经测试以上代码转码耗时过长。转码分为两部分，即解码和编码，而video标签中支持的MP4格式其实是视频h264编码和音频aac。所以即使原视频不是MP4格式，但是其音视频编码格式是h264和aac,那么转码无异于换一个文件后缀名。\n**那么重新审视以下video标签，即，该标签支持的是视频采用h264，音频采用aac编码的视频**\n###### FFmpge手动转码\n[FFmpge官网下载地址](http://www.ffmpeg.org/)\n下载后解压进入其bin目录下，执行以下命令解码：\n```\nffmpge -i \n-threads 6 //指定线程数\n\"G:\\PT\\送你一朵小红花.4K HDR10高码.A.Little.Red.Flower.2020.WEB-DL.2160p.H265.10bits.HDR10.DDP 5.1-PTHweb.mkv\" \n-vcodec h264 //指定视频编解码器\n-acodec aac //指定音频编解码器\n\"G:\\PT\\送你一朵小红花.4K HDR10高码.A.Little.Red.Flower.2020.WEB-DL.2160p.H265.10bits.HDR10.DDP 5.1-PTHweb.mp4\"\n```\n![image.png](http://localhost:9001/b9efc37d586b4540a53284a85748d799.png)', NULL, '1');
INSERT INTO `blog` VALUES (0065, 2, '间谍之妻', '', 'dfc29dfab6d443438546208a3ef6c156.png', 35, 26, '黑泽清', '2021-03-26 09:56:59', '', NULL, '0');
INSERT INTO `blog` VALUES (0066, 2, '咒术回战', '', '725ce0cdb28541568b5a11de7ab7c1ad.jfif', 35, 26, '', '2021-04-08 12:51:49', '<p>虽然剧情和人物设定和火影有很大的重叠，但也是一部优秀的作品。\n同样也能看到坚持不同理念的人，互相敌对厮杀，让人从不同立场出发去思考。</p>\n<p><img src=\"http://localhost:9001/b64889ee12e2460781d41b039e5cf76a.png\" alt=\"image.png\">\n虎杖悠仁\n当我们还没有找到人生的方向时，谁不是凭着一腔热血在活着，只是或偶然时听到的无心之言，或诀别时的语重心长，直击心脏。我们茅塞顿开，找到了可以坚持一辈子的信念。</p>\n<p><img src=\"http://localhost:9001/d4be621c22a0448b863bfbfc2c7c3e80.png\" alt=\"image.png\">\n伏黑惠\n家庭背景可以是一个人暂时的资源，但受欺负了就要找爸爸告状的始终是小孩。</p>\n<p><img src=\"http://localhost:9001/e873031a2cb4433a825720c8d332dfcc.png\" alt=\"image.png\">\n五条悟\n我以为我已经找到了正确的道路，这条路上有正义，有朋友。可是后来，我的朋友选择了一条完全相反的路，我才发现正义都是狗屁。我不是说和正义对着干的都是正确的，只是现在我只相信我认为正确的。</p>\n<p><img src=\"http://localhost:9001/e83ab4254aea4023a2bd64d5a234a15a.png\" alt=\"image.png\">\n夏油杰\n我忘了从什么时候开始相信，也忘了从什么时候开始质疑。</p>\n<p><img src=\"http://localhost:9001/1f069b2c5bfa4cec804087d5284a7ffe.png\" alt=\"image.png\">\n狗卷棘 &amp; panda</p>\n', NULL, '1');
INSERT INTO `blog` VALUES (0067, 2, 'Java学习笔记', '', '', 1, 7, '周鸣秋', '2021-04-08 13:20:52', '# Java\n\n## 1、基础知识\n\n### 1.1 变量与运算符\n\n#### 1.1.1 变量：\n\n##### 定义\n\n内存中的一个存储区域\n\n该区域的数据可以在同一类型范围内变化\n\n变量是程序中最基本的存储单元，包含**变量类型**、**变量名**、**值**\n\n##### 使用\n\n使用变量前需要**声明**并**赋值**\n\n变量只在其**作用域**内有效\n\n同一**作用域**内，不能出现同名的变量\n\n##### 类型\n\n###### 类变量（静态变量）\n\n**定义：**独立于方法之外的变量，用static修饰\n\n**特性：**\n\n> - 类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。\n> - 无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。\n> - 静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。\n> - 静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。\n> - 静态变量在**第一次被访问时创建**，在**程序结束时销毁**。\n> - 与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。\n> - 默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。\n> - 静态变量可以通过：*ClassName.VariableName*的方式访问。\n> - 类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。\n\n###### 实例变量（成员变量）\n\n**定义：**独立于方法之外的变量，没有static修饰\n\n**特性：**\n\n> - 实例变量声明在一个类中，但在方法、构造方法和语句块之外；\n> - 当一个对象被实例化之后，每个实例变量的值就跟着确定；\n> - 实例变量在对象创建的时候创建，在对象被销毁的时候销毁；\n> - 实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；\n> - 实例变量可以声明在使用前或者使用后；\n> - 访问修饰符可以修饰实例变量；\n> - 实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；\n> - **实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；**\n> - 实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。\n\n###### 局部变量\n\n**定义：**类的方法中的变量\n\n**特性：**\n\n> - 局部变量声明在方法、构造方法或者语句块中；\n> - 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；\n> - 访问修饰符不能用于局部变量；\n> - 局部变量只在声明它的方法、构造方法或者语句块中可见；\n> - 局部变量是在栈上分配的。\n> - **局部变量没有默认值**，所以局部变量被声明后，必须经过初始化，才可以使用。（此特性可以说明基本数据类型变量在数组中没有将其赋值时，能输出其默认值，但在作为局部变量时无法输出其默认值并报错）\n\n### 1.2 数据类型\n\n#### 1.2.1 基本数据类型\n\n##### 数值型\n\n- 整数类型：byte，short，int，long\n\n  | 类型  | 存储空间 | 数值范围                         | 声明                 |\n  | ----- | -------- | -------------------------------- | -------------------- |\n  | byte  | 1字节    | -128~127                         | byte b = 1           |\n  | short | 2字节    | 2<sup>15</sup> ~2<sup>15</sup>-1 | short s = 128        |\n  | int   | 4字节    | -2<sup>31</sup>~2<sup>31</sup>-1 | int i = 1            |\n  | long  | 8字节    | -2<sup>63</sup>~2<sup>63</sup>-1 | long l = 3414212345L |\n\n- 浮点类型：float，double\n\n  | 类型         | 存储空间 | 数值范围             | 声明            |\n  | ------------ | -------- | -------------------- | --------------- |\n  | 单精度float  | 4字节    | -3.403E38~3.403E38   | float f = 3.14F |\n  | 双精度double | 8字节    | -1.798E308~1.798E308 |                 |\n\n  注：double精度是float的两倍；**float数值范围比int、long大**；如果存储比精度更重要，请考虑对浮点变量使用 float 类型，相反，如果精度是最重要的条件，则使用 double 类型；\n\n##### 字符型\n\n​	char\n\n##### 布尔型\n\n​	boolean\n\n#### 1.2.2 引用数据类型\n\n##### 类：class\n\n##### 接口：interface\n\n##### 数组：[]\n\n### 1.3 关键字与保留字\n\n#### 1.3.1 关键字\n\n1. 数据类型\n\n   class, interface, enum, byte, short, int, long, float, double, char, boolean, void\n\n2. **流程控制**\n\n   if, else, switch, case, default, while, do, for, break, continue, return\n\n3. **访问权限修饰**\n\n   private, protected, public\n\n4. **类，函数，变量修饰符**\n\n   abstract, final, static, synchronized\n\n5. **类关系**\n\n   extends, implements\n\n6. **定义、创建、引用判断实例**\n\n   new, this, super, instanceof\n\n7. **异常**\n\n   try, catch, finally, throw\n\n8. **包**\n\n   package, import\n\n9. **其他修饰符**\n\n   native, stricfp, transient, volatile\n\n10. **非关键字，特殊值**\n\n    true, false, null\n\n#### 1.3.2 保留字\n\n**定义**：现有Java版本尚未使用，后续版本可能会作为关键字使用，命名时尽量避免。\n\n**保留字**：goto、const\n\n### 1.4 标识符\n\n**定义：**Java对各种变量、方法和类等要素命名时使用的字符序列称为标识符\n\n**命名规则：**\n\n1. 由26个英文字母大小写，0-9，_或者$组成\n2. 数字不可以开头\n3. 不可以使用关键字和保留字，但能包含关键字和保留字\n4. Java严格区分大小写，长度无限制\n5. 标识符不能包含空格\n\n### 1.5 修饰符\n\n#### 访问修饰符\n\n> - **default** (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。\n> - **private** : 在同一类内可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）**\n> - **public** : 对所有类可见。使用对象：类、接口、变量、方法\n> - **protected** : 对同一包内的类和所有子类可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）**。\n\n| 修饰符      | 当前类 | 同一包内 | 子孙类(同一包) | 子孙类(不同包)  | 其他包 |\n| :---------- | :----- | :------- | :------------- | :-------------- | :----- |\n| `public`    | Y      | Y        | Y              | Y               | Y      |\n| `protected` | Y      | Y        | Y              | Y/N<sup>①</sup> | N      |\n| `default`   | Y      | Y        | Y              | N               | N      |\n| `private`   | Y      | N        | N              | N               | N      |\n\n①：**子类与基类不在同一包中**：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。\n\n#### 访问控制和继承\n\n请注意以下方法继承的规则：\n\n> - 父类中声明为 public 的方法在子类中也必须为 public。\n> - 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。\n> - 父类中声明为 private 的方法，不能够被继承。\n\n#### 非访问修饰符\n\n**static**：修饰符，用来修饰方法和类变量。\n\n- 静态变量：\n\n  static关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。静态变量也被称为类变量。局部变量不能被声明为static变量。\n\n- 静态方法：\n\n  static关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。\n\n**final**：修饰符，用来修饰类、方法、和变量，final修饰的类不能够被继承，修饰的方法不能够被继承类重新定义，修饰的变量为常量，不可修改。\n\n- final变量：\n\n  final修饰符通常和static修饰符一起使用来创建类常量。\n\n- final方法：\n\n  父类的final方法可以被子类继承，但是不能被子类重写。所以声明final方法的主要目的是防止该方法内容被修改。\n\n- final类：\n\n  final类不能被继承，没有类能够继承final类的任何特性。\n\n**abstract**：修饰符，用来创建抽象类和抽象方法。\n\n```java\npublic abstract class SuperClass { // 抽象类 \n    abstract void test(); // 抽象方法\n}\nclass SubClass extends SuperClass { //继承抽象类\n    void test () {\n       // 实现抽象方法\n    }\n}\n```\n\n- 抽象类：\n\n  1、抽象类**不能**用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。\n\n  2、一个类不能**同时**被`abstract`和`final`修饰。**如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误**。\n\n  3、**抽象类可以包含抽象方法和非抽象方法**。\n\n- 抽象方法：\n\n  1、抽象方法是一种没有任何实现的方法，该方法的具体实现由子类提供。\n\n  2、抽象方法不能被声明成`final`和`static`。\n\n  3、**任何继承抽象类的子类必须实现父类的所有抽象方法**，除非该子类也是抽象类。\n\n  4、抽象类可以包含n个抽象方法（**n >= 0**）。\n\n  5、**如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误**。\n\n**synchronized**、**volatile**：修饰符，主要用于线程的编程。\n\n- **synchronized修饰符**\n\n  被synchronized修饰的方法**同一时间只能被一个线程访问**。**synchronized可以应用于所有访问修饰符**。\n\n- **volatile修饰符**\n\n  volatile修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。\n\n**transient**：修饰符\n\n序列化的对象包含被transient修饰的变量时，Java虚拟机跳过该特定的变量。\n\n该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。\n\n### 1.6 运算符\n\n#### 1.6.1 算术运算符\n\n| 操作符 | 描述                              | 例子                               |\n| :----- | :-------------------------------- | :--------------------------------- |\n| +      | 加法 - 相加运算符两侧的值         | A + B 等于 30                      |\n| -      | 减法 - 左操作数减去右操作数       | A – B 等于 -10                     |\n| *      | 乘法 - 相乘操作符两侧的值         | A * B等于200                       |\n| /      | 除法 - 左操作数除以右操作数       | B / A等于2                         |\n| ％     | 取余 - 左操作数除以右操作数的余数 | B%A等于0                           |\n| ++     | 自增: 操作数的值增加1             | B++ 或 ++B 等于 21（区别详见下文） |\n| --     | 自减: 操作数的值减少1             | B-- 或 --B 等于 19（区别详见下文） |\n\n**前缀自增自减法(++a,--a):** 先进行自增或者自减运算，再进行表达式运算。\n\n**后缀自增自减法(a++,a--):** 先进行表达式运算，再进行自增或者自减运算 。\n\n#### 1.6.2 关系运算符\n\n| 运算符 | 描述                                                         | 例子             |\n| :----- | :----------------------------------------------------------- | :--------------- |\n| ==     | 检查如果两个操作数的值是否相等，如果相等则条件为真。         | （A == B）为假。 |\n| !=     | 检查如果两个操作数的值是否相等，如果值不相等则条件为真。     | (A != B) 为真。  |\n| >      | 检查左操作数的值是否大于右操作数的值，如果是那么条件为真。   | （A> B）为假。   |\n| <      | 检查左操作数的值是否小于右操作数的值，如果是那么条件为真。   | （A <B）为真。   |\n| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。 | （A> = B）为假。 |\n| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。 | （A <= B）为真。 |\n\n#### 1.6.3 位运算符\n\n下表列出了位运算符的基本运算，假设整数变量 A 的值为 60 （0011 1100）和变量 B（0000 1101） 的值为 13：\n\n| 操作符 | 描述                                                         | 例子                           |\n| :----- | :----------------------------------------------------------- | :----------------------------- |\n| ＆     | 如果相对应位都是1，则结果为1，否则为0                        | （A＆B），得到12，即0000 1100  |\n| \\|     | 如果相对应位都是 0，则结果为 0，否则为 1                     | （A \\| B）得到61，即 0011 1101 |\n| ^      | 如果相对应位值相同，则结果为0，否则为1                       | （A ^ B）得到49，即 0011 0001  |\n| 〜     | 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。         | （〜A）得到-61，即1100 0011    |\n| <<     | 按位左移运算符。左操作数按位左移右操作数指定的位数。         | A << 2得到240，即 1111 0000    |\n| >>     | 按位右移运算符。左操作数按位右移右操作数指定的位数。         | A >> 2得到15即 1111            |\n| >>>    | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 | A>>>2得到15即0000 1111         |\n\n#### 1.6.4 逻辑运算符\n\n| 操作符 | 描述                                                         | 例子                |\n| :----- | :----------------------------------------------------------- | :------------------ |\n| &&     | 称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。     | （A && B）为假。    |\n| \\| \\|  | 称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 | （A \\| \\| B）为真。 |\n| ！     | 称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 | ！（A && B）为真。  |\n\n#### 1.6.5 赋值运算符\n\n| 作符    | 描述                                                         | 例子                                     |\n| :------ | :----------------------------------------------------------- | :--------------------------------------- |\n| =       | 简单的赋值运算符，将右操作数的值赋给左侧操作数               | C = A + B将把A + B得到的值赋给C          |\n| + =     | 加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数     | C + = A等价于C = C + A                   |\n| - =     | 减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数     | C - = A等价于C = C - A                   |\n| * =     | 乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数     | C * = A等价于C = C * A                   |\n| / =     | 除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数     | C / = A，C 与 A 同类型时等价于 C = C / A |\n| （％）= | 取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数 | C％= A等价于C = C％A                     |\n| << =    | 左移位赋值运算符                                             | C << = 2等价于C = C << 2                 |\n| >> =    | 右移位赋值运算符                                             | C >> = 2等价于C = C >> 2                 |\n| ＆=     | 按位与赋值运算符                                             | C＆= 2等价于C = C＆2                     |\n| ^ =     | 按位异或赋值操作符                                           | C ^ = 2等价于C = C ^ 2                   |\n| \\| =    | 按位或赋值操作符                                             | C \\| = 2等价于C = C \\| 2                 |\n\n#### 1.6.6 条件运算符\n\n条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。\n\n```java\nint a = 1;\nint b = 2;\nint c = a > b ? a : b // c = 2\n```\n\n#### 1.6.7 instanceof运算符\n\n该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。\n\ninstanceof运算符使用格式如下：\n\n```java\n( Object reference variable ) instanceof  (class/interface type)\n```\n\n如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。\n\n下面是一个例子：\n\n```java\nString name = \"James\";\nboolean result = name instanceof String; // 由于 name 是 String 类型，所以返回真\n```\n\n#### 1.6.8 运算符优先级\n\n下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。\n\n| 类别     | 操作符                                     | 关联性   |\n| :------- | :----------------------------------------- | :------- |\n| 后缀     | () [] . (点操作符)                         | 左到右   |\n| 一元     | expr++ expr--                              | 从左到右 |\n| 一元     | ++expr --expr + - ～ ！                    | 从右到左 |\n| 乘性     | * /％                                      | 左到右   |\n| 加性     | + -                                        | 左到右   |\n| 移位     | >> >>>  <<                                 | 左到右   |\n| 关系     | > >= < <=                                  | 左到右   |\n| 相等     | == !=                                      | 左到右   |\n| 按位与   | ＆                                         | 左到右   |\n| 按位异或 | ^                                          | 左到右   |\n| 按位或   | \\|                                         | 左到右   |\n| 逻辑与   | &&                                         | 左到右   |\n| 逻辑或   | \\| \\|                                      | 左到右   |\n| 条件     | ？：                                       | 从右到左 |\n| 赋值     | = + = - = * = / =％= >> = << =＆= ^ = \\| = | 从右到左 |\n| 逗号     | ，                                         | 左到右   |\n\n### 1.7 命名规范\n\n1. **包名：**多单词组成时所有字母小写:xxxyyyzzz\n\n2. **类、接口名：**多单词组成时，所有单词的首字母大写：XxxYyyZzz\n\n3. **变量、方法名：**多单侧组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz\n\n4. **常量名：**所有字母都大写，多单词组成时每个单词用下划线连接：XXX_YYY_ZZZ\n\n   注：Java采用Unicode字符集，因此标识符可以使用汉字声明，但是不建议使用\n\n### 1.8 对象和类\n\n##### 对象\n\n对象是类的一个实例\n\n##### 类\n\n类是一个模板，他描述一类对象的状态(成员变量)和行为(成员方法)\n\n### 1.9 包装类\n\nJava语言是面向对象的语言，但是Java中基本数据类型却不是面向对象的，即基本类型的数据不具备“对象”的特性（没有成员变量和方法），因此，Java为每种数据类型分别设计了对应的类，即包装类。\n\n| 基本数据类型 | 包装类    | 父类   | 装箱      | 拆箱           |\n| ------------ | --------- | ------ | --------- | -------------- |\n| byte         | Byte      | Number | valueOf() | byteValue()    |\n| short        | Short     | Number | valueOf() | shortValue()   |\n| int          | Integer   | Numbe  | valueOf() | intValue()     |\n| long         | Long      | Number | valueOf() | longValue()    |\n| float        | Float     | Number | valueOf() | floatValue()   |\n| double       | Double    | Number | valueOf() | doubleValue()  |\n| char         | Character | Object | valueOf() | charValue()    |\n| boolean      | Boolean   | Object | valueOf() | booleanValue() |\n\n#### 1.9.1 Number & Math\n\n所有的包装类**（Integer、Long、Byte、Double、Float、Short）**都是**抽象类** Number 的子类。\n\nJava 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。\n\nMath 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。\n\n**常用方法**\n\n| 序号 | 方法与描述                                                   |\n| :--- | :----------------------------------------------------------- |\n| 1    | xxxValue()将 Number 对象转换为xxx数据类型的值并返回。        |\n| 2    | compareTo() 将number对象与参数比较。                         |\n| 3    | equals() 判断number对象是否与参数相等。                      |\n| 4    | valueOf() 返回一个 Number 对象指定的内置数据类型             |\n| 5    | toString() 以字符串形式返回值。                              |\n| 6    | [parseInt()](https://www.runoob.com/java/number-parseInt.html) 将字符串解析为int类型。 |\n| 7    | [abs()](https://www.runoob.com/java/number-abs.html) 返回参数的绝对值。 |\n| 8    | ceil() 返回大于等于( >= )给定参数的的最小整数，类型为双精度浮点型。 |\n| 9    | [floor()](https://www.runoob.com/java/number-floor.html) 返回小于等于（<=）给定参数的最大整数 。 |\n| 10   | [rint()](https://www.runoob.com/java/number-rint.html) 返回与参数最接近的整数。返回类型为double。 |\n| 11   | [round()](https://www.runoob.com/java/number-round.html) 它表示**四舍五入**，算法为 **Math.floor(x+0.5)**，即将原来的数字加上 0.5 后再向下取整，所以，Math.round(11.5) 的结果为12，Math.round(-11.5) 的结果为-11。 |\n| 12   | [min()](https://www.runoob.com/java/number-min.html) 返回两个参数中的最小值。 |\n| 13   | [max()](https://www.runoob.com/java/number-max.html) 返回两个参数中的最大值。 |\n| 14   | [exp()](https://www.runoob.com/java/number-exp.html) 返回自然数底数e的参数次方。 |\n| 15   | [log()](https://www.runoob.com/java/number-log.html) 返回参数的自然数底数的对数值。 |\n| 16   | [pow()](https://www.runoob.com/java/number-pow.html) 返回第一个参数的第二个参数次方。 |\n| 17   | [sqrt()](https://www.runoob.com/java/number-sqrt.html) 求参数的算术平方根。 |\n| 18   | [sin()](https://www.runoob.com/java/number-sin.html) 求指定double类型参数的正弦值。 |\n| 19   | [cos()](https://www.runoob.com/java/number-cos.html) 求指定double类型参数的余弦值。 |\n| 20   | [tan()](https://www.runoob.com/java/number-tan.html) 求指定double类型参数的正切值。 |\n| 21   | [asin()](https://www.runoob.com/java/number-asin.html) 求指定double类型参数的反正弦值。 |\n| 22   | [acos()](https://www.runoob.com/java/number-acos.html) 求指定double类型参数的反余弦值。 |\n| 23   | [atan()](https://www.runoob.com/java/number-atan.html) 求指定double类型参数的反正切值。 |\n| 24   | [atan2()](https://www.runoob.com/java/number-atan2.html) 将笛卡尔坐标转换为极坐标，并返回极坐标的角度值。 |\n| 25   | [toDegrees()](https://www.runoob.com/java/number-todegrees.html) 将参数转化为角度。 |\n| 26   | toRadians() 将角度转换为弧度。                               |\n| 27   | random() 返回一个随机数。                                    |\n\n#### 1.9.2 Character\n\nCharacter 类用于对单个字符进行操作。\n\nCharacter 类在对象中包装一个基本类型 **char** 的值。\n\n**转义**\n\n前面有反斜杠（\\）的字符代表转义字符，它对编译器来说是有特殊含义的。\n\n下面列表展示了Java的转义序列：\n\n| 转义序列 | 描述                     |\n| :------- | :----------------------- |\n| \\t       | 在文中该处插入一个tab键  |\n| \\b       | 在文中该处插入一个后退键 |\n| \\n       | 在文中该处换行           |\n| \\r       | 在文中该处插入回车       |\n| \\f       | 在文中该处插入换页符     |\n| \\\'       | 在文中该处插入单引号     |\n| \\\"       | 在文中该处插入双引号     |\n| \\\\       | 在文中该处插入反斜杠     |\n\n**常用方法**\n\n下面是Character类的方法：\n\n| 序号 | 方法与描述                                                   |\n| :--- | :----------------------------------------------------------- |\n| 1    | isLetter() 是否是一个字母                                    |\n| 2    | [isDigit()](https://www.runoob.com/java/character-isdigit.html) 是否是一个数字字符 |\n| 3    | [isWhitespace()](https://www.runoob.com/java/character-iswhitespace.html) 是否是一个空白字符 |\n| 4    | [isUpperCase()](https://www.runoob.com/java/character-isuppercase.html) 是否是大写字母 |\n| 5    | [isLowerCase()](https://www.runoob.com/java/character-islowercase.html) 是否是小写字母 |\n| 6    | [toUpperCase()](https://www.runoob.com/java/character-touppercase.html) 指定字母的大写形式 |\n| 7    | [toLowerCase](https://www.runoob.com/java/character-tolowercase.html)() 指定字母的小写形式 |\n| 8    | [toString](https://www.runoob.com/java/character-tostring.html)() 返回字符的字符串形式，字符串的长度仅为1 |\n\n### 1.10 String\n\n**String对象内容不能修改，只能创建新的String对象然后改变变量的引用**\n\n**创建方法**\n\n```\nString test1 = \"test\"; // 存储在method area中\nString test2 = \"test\"; // 和test1的相同引用\nString test3 = new String(\"test\"); // 实例化新的String对象，存储在heap中\nString test4 = new String(\"test\"); // 实例化新的String对象\n// test1 == test2 != test3 != test4\n```\n\n**常用方法**\n\n| SN(序号) | 方法描述                                                     |\n| :------- | :----------------------------------------------------------- |\n| 1        | char charAt(int index) 返回指定索引处的 char 值。            |\n| 2        | [int compareTo(Object o)](https://www.runoob.com/java/java-string-compareto.html) 把这个字符串和另一个对象比较。 |\n| 3        | [int compareTo(String anotherString)](https://www.runoob.com/java/java-string-compareto.html) 按字典顺序比较两个字符串。 |\n| 4        | [int compareToIgnoreCase(String str)](https://www.runoob.com/java/java-string-comparetoignorecase.html) 按字典顺序比较两个字符串，不考虑大小写。 |\n| 5        | [String concat(String str)](https://www.runoob.com/java/java-string-concat.html) 将指定字符串连接到此字符串的结尾。 |\n| 6        | [boolean contentEquals(StringBuffer sb)](https://www.runoob.com/java/java-string-contentequals.html) 当且仅当字符串与指定的StringBuffer有相同顺序的字符时候返回真。 |\n| 7        | [static String copyValueOf(char[\\] data)](https://www.runoob.com/java/java-string-copyvalueof.html) 返回指定数组中表示该字符序列的 String。 |\n| 8        | [static String copyValueOf(char[\\] data, int offset, int count)](https://www.runoob.com/java/java-string-copyvalueof.html) 返回指定数组中表示该字符序列的 String。 |\n| 9        | [boolean endsWith(String suffix)](https://www.runoob.com/java/java-string-endswith.html) 测试此字符串是否以指定的后缀结束。 |\n| 10       | [boolean equals(Object anObject)](https://www.runoob.com/java/java-string-equals.html) 将此字符串与指定的对象比较。 |\n| 11       | [boolean equalsIgnoreCase(String anotherString)](https://www.runoob.com/java/java-string-equalsignorecase.html) 将此 String 与另一个 String 比较，不考虑大小写。 |\n| 12       | [byte[\\] getBytes()](https://www.runoob.com/java/java-string-getbytes.html)  使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 |\n| 13       | [byte[\\] getBytes(String charsetName)](https://www.runoob.com/java/java-string-getbytes.html) 使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 |\n| 14       | [void getChars(int srcBegin, int srcEnd, char[\\] dst, int dstBegin)](https://www.runoob.com/java/java-string-getchars.html) 将字符从此字符串复制到目标字符数组。 |\n| 15       | [int hashCode()](https://www.runoob.com/java/java-string-hashcode.html) 返回此字符串的哈希码。 |\n| 16       | [int indexOf(int ch)](https://www.runoob.com/java/java-string-indexof.html) 返回指定字符在此字符串中第一次出现处的索引。 |\n| 17       | [int indexOf(int ch, int fromIndex)](https://www.runoob.com/java/java-string-indexof.html) 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。 |\n| 18       | [int indexOf(String str)](https://www.runoob.com/java/java-string-indexof.html)  返回指定子字符串在此字符串中第一次出现处的索引。 |\n| 19       | [int indexOf(String str, int fromIndex)](https://www.runoob.com/java/java-string-indexof.html) 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。 |\n| 20       | [String intern()](https://www.runoob.com/java/java-string-intern.html)  返回字符串对象的规范化表示形式。 |\n| 21       | [int lastIndexOf(int ch)](https://www.runoob.com/java/java-string-lastindexof.html)  返回指定字符在此字符串中最后一次出现处的索引。 |\n| 22       | [int lastIndexOf(int ch, int fromIndex)](https://www.runoob.com/java/java-string-lastindexof.html) 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。 |\n| 23       | [int lastIndexOf(String str)](https://www.runoob.com/java/java-string-lastindexof.html) 返回指定子字符串在此字符串中最右边出现处的索引。 |\n| 24       | [int lastIndexOf(String str, int fromIndex)](https://www.runoob.com/java/java-string-lastindexof.html)  返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。 |\n| 25       | [int length()](https://www.runoob.com/java/java-string-length.html) 返回此字符串的长度。 |\n| 26       | [boolean matches(String regex)](https://www.runoob.com/java/java-string-matches.html) 告知此字符串是否匹配给定的正则表达式。 |\n| 27       | [boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)](https://www.runoob.com/java/java-string-regionmatches.html) 测试两个字符串区域是否相等。 |\n| 28       | [boolean regionMatches(int toffset, String other, int ooffset, int len)](https://www.runoob.com/java/java-string-regionmatches.html) 测试两个字符串区域是否相等。 |\n| 29       | [String replace(char oldChar, char newChar)](https://www.runoob.com/java/java-string-replace.html) 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 |\n| 30       | [String replaceAll(String regex, String replacement)](https://www.runoob.com/java/java-string-replaceall.html) 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 |\n| 31       | [String replaceFirst(String regex, String replacement)](https://www.runoob.com/java/java-string-replacefirst.html)  使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。 |\n| 32       | [String[\\] split(String regex)](https://www.runoob.com/java/java-string-split.html) 根据给定正则表达式的匹配拆分此字符串。 |\n| 33       | [String[\\] split(String regex, int limit)](https://www.runoob.com/java/java-string-split.html) 根据匹配给定的正则表达式来拆分此字符串。 |\n| 34       | [boolean startsWith(String prefix)](https://www.runoob.com/java/java-string-startswith.html) 测试此字符串是否以指定的前缀开始。 |\n| 35       | [boolean startsWith(String prefix, int toffset)](https://www.runoob.com/java/java-string-startswith.html) 测试此字符串从指定索引开始的子字符串是否以指定前缀开始。 |\n| 36       | [CharSequence subSequence(int beginIndex, int endIndex)](https://www.runoob.com/java/java-string-subsequence.html)  返回一个新的字符序列，它是此序列的一个子序列。 |\n| 37       | [String substring(int beginIndex)](https://www.runoob.com/java/java-string-substring.html) 返回一个新的字符串，它是此字符串的一个子字符串。 |\n| 38       | [String substring(int beginIndex, int endIndex)](https://www.runoob.com/java/java-string-substring.html) 返回一个新字符串，它是此字符串的一个子字符串。 |\n| 39       | [char[\\] toCharArray()](https://www.runoob.com/java/java-string-tochararray.html) 将此字符串转换为一个新的字符数组。 |\n| 40       | [String toLowerCase()](https://www.runoob.com/java/java-string-tolowercase.html) 使用默认语言环境的规则将此 String 中的所有字符都转换为小写。 |\n| 41       | [String toLowerCase(Locale locale)](https://www.runoob.com/java/java-string-tolowercase.html)  使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。 |\n| 42       | [String toString()](https://www.runoob.com/java/java-string-tostring.html)  返回此对象本身（它已经是一个字符串！）。 |\n| 43       | [String toUpperCase()](https://www.runoob.com/java/java-string-touppercase.html) 使用默认语言环境的规则将此 String 中的所有字符都转换为大写。 |\n| 44       | [String toUpperCase(Locale locale)](https://www.runoob.com/java/java-string-touppercase.html) 使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。 |\n| 45       | [String trim()](https://www.runoob.com/java/java-string-trim.html) 返回字符串的副本，忽略前导空白和尾部空白。 |\n| 46       | [static String valueOf(primitive data type x)](https://www.runoob.com/java/java-string-valueof.html) 返回给定data type类型x参数的字符串表示形式。 |\n| 47       | [contains(CharSequence chars)](https://www.runoob.com/java/java-string-contains.html) 判断是否包含指定的字符系列。 |\n| 48       | isEmpty() 判断字符串是否为空。                               |\n\n### 1.11 StringBuffer & StringBuilder\n\n当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。\n\n和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且**不产生新的未使用对象**。\n\n在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，所以如果需要对字符串进行修改推荐使用 StringBuffer。\n\nStringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。\n\n由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。\n\n**使用**\n\n```java\nStringBuffer stringBuffer = new StringBuffer();\nStringBuilder stringBuilder = new StringBuilder();\nstringBuffer.append(\"Miatum\");\nstringBuffer.insert(1, \"insert\");\nstringBuilder.append(\"dog is dog, pig is pig\");\nstringBuilder.delete(1, 4);\nSystem.out.println(stringBuffer);\nSystem.out.println(stringBuilder);\n```\n\n### 1.12 循环\n\n#### 1.10.1 while循环\n\n```java\nwhile (布尔表达式) {\n    // 循环内容\n}\n```\n\n#### 1.10.2 do while循环\n\n一是为了弄明白do while和while循环的区别，二是因为do while没有其他循环结构常用，因此详细写do while的用法。\n\n```java\ndo {\n    // 循环内容\n} while (布尔表达式);\n```\n\n对于while语句而言，如果不满足条件，则不能进入循环。但有时我们需要即使不满足条件也至少执行一次循环内容，此时do while便适用。\n\n#### 1.10.3 for循环\n\n```java\nfor (初始化; 布尔表达式; 更新) {\n    // 循环内容\n} \n```\n\n### 1.13 条件\n\n#### 1.11.1 if...else\n\nif...else语句可以嵌套使用，但通常不建议，嵌套会降低代码的可阅读性。\n\n```java\nif (布尔表达式) {\n    // 代码语句\n} else if(布尔表达式) {\n    // 代码语句\n} else {\n    // 代码语句\n}\n```\n\n#### 1.11.2 switch...case\n\n> - switch 语句中的变量类型可以是： **byte**、**short**、**int** 或者 **char**。从 **Java SE 7** 开始，switch 支持字符串 **String** 类型了，**同时 case 标签必须为字符串常量或字面量**。\n> - switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。\n> - case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。\n> - 当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。\n> - 当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。\n> - switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。**default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句**。\n\n```java\nswitch (expression) {\n    case value: \n        // code;\n        break; // 可选\n    default: // 可选\n        // code;\n}\n```\n\n### 1.14 数组\n\n**初始化**\n\n```java\ndataType[] arrayName = new dataType[arraySize];\ndataType[] arrayName = {value1, value2, value3, ...};\n```\n\n**Arrays类**\n\njava.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。\n\n具有以下功能：\n\n> - 给数组赋值：通过 fill 方法。\n> - 对数组排序：通过 sort 方法,按升序。\n> - 比较数组：通过 equals 方法比较数组中元素值是否相等。\n> - 查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。\n\n| 序号 | 方法和说明                                                   |\n| :--- | :----------------------------------------------------------- |\n| 1    | **public static int binarySearch(Object[] a, Object key)** 用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(*插入点*) - 1)。 |\n| 2    | **public static boolean equals(long[] a, long[] a2)** 如果两个指定的 long 型数组彼此*相等*，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 |\n| 3    | **public static void fill(int[] a, int val)** 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 |\n| 4    | **public static void sort(Object[] a)** 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。 |\n\n### 1.15 日期时间\n\n#### Date\n\njava.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。\n\n第一个构造函数使用当前日期和时间来初始化对象。\n\n```java\nDate date = new Date( );\n```\n\n第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。\n\n```java\nDate date = Date(long millisec);\n```\n\nDate对象创建以后，可以调用下面的方法。\n\n| 序号 | 方法和描述                                                   |\n| :--- | :----------------------------------------------------------- |\n| 1    | **boolean after(Date date)** 若当调用此方法的Date对象在指定日期之后返回true,否则返回false。 |\n| 2    | **boolean before(Date date)** 若当调用此方法的Date对象在指定日期之前返回true,否则返回false。 |\n| 3    | **Object clone( )** 返回此对象的副本。                       |\n| 4    | **int compareTo(Date date)** 比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。 |\n| 5    | **int compareTo(Object obj)** 若obj是Date类型则操作等同于compareTo(Date) 。否则它抛出ClassCastException。 |\n| 6    | **boolean equals(Object date)** 当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。 |\n| 7    | **long getTime( )** 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 |\n| 8    | **int hashCode( )**  返回此对象的哈希码值。                  |\n| 9    | **void setTime(long time)**   用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。 |\n| 10   | **String toString( )** 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)。 |\n\n#### SimpleDateFormat\n\n```java\nDate date = new Date();\nSimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");\nSystem.out.print(df.format(date));\n```\n\n**TimeZone时区**\n\n```java\nTimeZone usaTimeZone = TimeZone.getTimeZone(\"America/Los_Angeles\"); //洛杉矶时区\ndf.setTimeZone(usaTimeZone);\n```\n\n**Locale地区**\n\n```\nLocale locale = Locale.getDefault(); // 获取默认地区\n```\n\n\n\n| **字母** | **描述**                 | **示例**                |\n| :------- | :----------------------- | :---------------------- |\n| G        | 纪元标记                 | AD                      |\n| y        | 四位年份                 | 2001                    |\n| M        | 月份                     | July or 07              |\n| d        | 一个月的日期             | 10                      |\n| h        | A.M./P.M. (1~12)格式小时 | 12                      |\n| H        | 一天中的小时 (0~23)      | 22                      |\n| m        | 分钟数                   | 30                      |\n| s        | 秒数                     | 55                      |\n| S        | 毫秒数                   | 234                     |\n| E        | 星期几                   | Tuesday                 |\n| D        | 一年中的日子             | 360                     |\n| F        | 一个月中第几周的周几     | 2 (second Wed. in July) |\n| w        | 一年中第几周             | 40                      |\n| W        | 一个月中第几周           | 1                       |\n| a        | A.M./P.M. 标记           | PM                      |\n| k        | 一天中的小时(1~24)       | 24                      |\n| K        | A.M./P.M. (0~11)格式小时 | 10                      |\n| z        | 时区                     | Eastern Standard Time   |\n| \'        | 文字定界符               | Delimiter               |\n| \"        | 单引号                   | `                       |\n\n如果是控制台打印时间，printf()提供了更为直接的方法，使用两个字母格式，它以 **%t** 开头并且以下面表格中的一个字母结尾。\n\n| 转 换 符 | 说  明                      | 示  例                        |\n| :------- | :-------------------------- | :---------------------------- |\n| c        | 包括全部日期和时间信息      | 周一 3月 01 12:27:40 CST 2021 |\n| F        | \"年-月-日\"格式              | 2021-03-01                    |\n| D        | \"月/日/年\"格式              | 03/01/21                      |\n| r        | \"HH:MM:SS PM\"格式（12时制） | 12:30:30 下午                 |\n| T        | \"HH:MM:SS\"格式（24时制）    | 12:30:45                      |\n| R        | \"HH:MM\"格式（24时制）       | 12:31                         |\n\n```java\nDate date = new Date();\nSystem.out.printf(\"%tc\", date); // 周一 3月 01 12:27:40 CST 2021\nSystem.out.printf(\"%tF\", date); // 2021-03-01\n...\n```\n\n#### Calendar\n\n**Calendar类是一个抽象类**，在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可。\n\n```java\nCalendar calendar = Calendar.getInstance();\ncalendar.set(2021, Calendar.MARCH, 1, 12, 44, 56); // Calendar.MARCH == 2\ncalendar.get(Calendar.YEAR); // 2021\ncalendar.get(Calendar.DAY_OF_MONTH); // 2\ncalendar.get(Calendar.DAY_OF_WEEK); // 2\n```\n\n**注意：Java中Calendar.MONTH返回的数值其实是当前月距离第一个月有多少个月份的数值，设置时如用int类型需要将值减一，获取月份时需要将值加一，因此建议用Calendar类自带的月份变量进行赋值。Calendar.DAY_OF_WEEK返回值1表示星期天，2表示星期一，以此类推。**\n\n| 常量                  | 描述                           |\n| :-------------------- | :----------------------------- |\n| Calendar.YEAR         | 年份                           |\n| Calendar.MONTH        | 月份                           |\n| Calendar.DATE         | 日期                           |\n| Calendar.DAY_OF_MONTH | 日期，和上面的字段意义完全相同 |\n| Calendar.HOUR         | 12小时制的小时                 |\n| Calendar.HOUR_OF_DAY  | 24小时制的小时                 |\n| Calendar.MINUTE       | 分钟                           |\n| Calendar.SECOND       | 秒                             |\n| Calendar.DAY_OF_WEEK  | 星期几                         |\n\n**Calendar.add()方法**\n\n```java\nCalendar calendar = Calendar.getInstance();\ncalendar.set(2021, Calendar.MARCH, 1, 12, 44, 56);\ncalendar.add(Calendar.YEAR, 1); // 2022\ncalendar.add(Calendar.MONTH, 2); // 4\n...\n```\n\n#### GregorianCalendar\n\nCalendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。\n\n**Calendar 的getInstance（）方法返回一个默认用当前的地区和时区初始化的GregorianCalendar对象**。\n\nGregorianCalendar类的构造方法：\n\n| **序号** | **构造函数和说明**                                           |\n| -------- | ------------------------------------------------------------ |\n| 1        | **GregorianCalendar()** 在具有默认语言环境的默认时区内使用当前时间构造一个默认的 GregorianCalendar。 |\n| 2        | **GregorianCalendar(int year, int month, int date)** 在具有默认语言环境的默认时区内构造一个带有给定日期设置的 GregorianCalendar |\n| 3        | **GregorianCalendar(int year, int month, int date, int hour, int minute)** 为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。 |\n| 4        | **GregorianCalendar(int year, int month, int date, int hour, int minute, int second)**  为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。 |\n| 5        | **GregorianCalendar(Locale aLocale)** 在具有给定语言环境的默认时区内构造一个基于当前时间的 GregorianCalendar。 |\n| 6        | **GregorianCalendar(TimeZone zone)** 在具有默认语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。 |\n| 7        | **GregorianCalendar(TimeZone zone, Locale aLocale)**  在具有给定语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。 |\n\n### 1.16 正则表达式\n\njava.util.regex 包主要包括以下三个类：\n\n> - Pattern 类：\n>\n>   pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。\n>\n> - Matcher 类：\n>\n>   Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。\n>\n> - PatternSyntaxException：\n>\n>   PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。\n\n### 1.17 方法\n\n例如System.out.print()，System为系统类，out为System类中静态变量（public static final PrintStream out = null），print()则为System类中的一个**方法**。\n\n**定义**\n\n> - 方法是解决一类问题的步骤的有序组合\n> - 方法包含于类或对象中\n> - 方法在程序中被创建，在其他地方被引用\n> - 无返回值方法，返回值类型为void\n\n**优点**\n\n> - 使程序变得更简短而清晰。\n> - 有利于程序维护。\n> - 可以提高程序开发的效率。\n> - 提高了代码的重用性。\n\n```java\npublic class Test () {\n    修饰符 返回值类型 方法名 (参数类型 参数) {\n        方法体;\n        return 返回值;\n    }\n    private int sum (int para1, int para2) {\n        int sum = para1 + para2;\n        return sum;\n    }   \n}\n\n```\n\n**调用**\n\n1、方法所在类里的调用：sum()。\n\n2、跨类调用，需要先实例化一个方法所在类的对象，test.sum();\n\n3、如果该方法为静态方法，则不用实例化对象，Test.sum();\n\n**重载**\n\n上面的sum()方法仅仅适用于int类型数据，如果需要求两个浮点型数据的和，则可以创建一个**方法名相同**，**参数不同**的方法。\n\n```java\nprivate int sum (double para1, double para2) {\n    double sum = para1 + para2;\n    return sum;\n}\n```\n\n如果你调用sum方法时传递的是int型参数，则 int型参数的max方法就会被调用；\n\n如果传递的是double型参数，则double类型的max方法体会被调用，这叫做方法重载；\n\n**可变参数**\n\n在方法声明中，在指定参数类型后加一个省略号(...) 。\n\n一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。\n\n\n\n**finalize() 方法**\n\nJava 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。\n\n例如，你可以使用 finalize() 来确保一个对象打开的文件被关闭了。\n\n在 finalize() 方法里，你必须指定在对象销毁时候要执行的操作。\n\n```java\npublic class FinalizationDemo {  \n  public static void main(String[] args) {  \n    Cake c1 = new Cake(1);  \n    Cake c2 = new Cake(2);  \n    Cake c3 = new Cake(3);  \n      \n    c2 = c3 = null;  \n    System.gc(); //调用Java垃圾收集器\n  }  \n}  \n \nclass Cake extends Object {  \n  private int id;  \n  public Cake(int id) {  \n    this.id = id;  \n    System.out.println(\"Cake Object \" + id + \"is created\");  \n  }  \n    \n  protected void finalize() throws java.lang.Throwable {  \n    super.finalize();  \n    System.out.println(\"Cake Object \" + id + \"is disposed\");  \n  }  \n}\n```\n\n输出：\n\n```java\n$ javac FinalizationDemo.java \n$ java FinalizationDemo\nCake Object 1is created\nCake Object 2is created\nCake Object 3is created\nCake Object 3is disposed\nCake Object 2is disposed\n```\n\n### 1.18 Stream、File、IO\n\nJava.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。\n\nJava.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。\n\n一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。\n\n#### 控制台输入\n\n控制台输入由System.in完成，具体实现需要借助实例化的BufferedReader或者Scanner对象。\n\n```java\npublic class IO {\n    private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    private Scanner scanner = new Scanner(System.in); // 常用方法：next(), nextDateType(), nextLine()\n    // 控制台输入\n    public void getCharFromConsole () throws IOException {\n        int temp;\n        String input = \"\";\n        System.out.println(\"read()读取单个字符，q键退出。\");\n        while ( (temp = br.read()) > 0) {\n            if ((char)temp != \'q\') {\n                input += (char)temp;\n            } else {\n                br.close();\n                System.out.println(input);\n            }\n        }\n    }\n    public void getStringFromConsole() throws IOException {\n        String input = \"\";\n        System.out.println(\"请输入：\");\n        do {\n            input = br.readLine();\n            System.out.println(input);\n        } while (!input.equals(\"end\"));\n    }\n    // 控制台输出\n\n}\n```\n\n#### 控制台输出\n\n控制台的输出由 print( ) 和 println() 完成，这些方法都由类 PrintStream 定义，System.out 是该类对象的一个引用。\n\nPrintStream 继承了 OutputStream类，并且实现了方法 write()。这样，write() 也可以用来往控制台写操作。\n\n```java\n// PrintStream的构造方法\npublic PrintStream(OutputStream out) {\n    this(out, false);\n}\n// PrintStream的实例化\nPrintStream ps = new PrintStream(System.out);\n```\n\n#### 读写文件\n\n##### **FileInputStream**\n\n```java\n// 实例化法一\nInputStream is = New FileInputStream(\"E:/Miatum/Java.md\");\n// 实例化法二\nFile file = new File(\"E:/Miatum/Java.md\");\nInputStream is = new FileInputStream(file);\n// read()用法\nint readResult = 0;\nwhile ( (readResult = is.read()) != -1) {\n    (char)readResult; // 读取一个字节，is.read()返回值为int,即读取字节的二进制值转十进制，如# == 35\n}\n```\n\n创建了InputStream对象，就可以使用下面的方法来读取流或者进行其他的流操作。\n\n| **序号** | **方法及描述**                                               |\n| :------- | :----------------------------------------------------------- |\n| 1        | **public void close() throws IOException{}** 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。 |\n| 2        | **protected void finalize()throws IOException {}** 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。 |\n| 3        | **public int read(int r)throws IOException{}** 这个方法从 InputStream 对象读取指定字节的数据。返回为整数值。返回下一字节数据，如果已经到结尾则返回-1。 |\n| 4        | **public int read(byte[] r) throws IOException{}** 这个方法从输入流读取r.length长度的字节。返回读取的字节数。如果是文件结尾则返回-1。 |\n| 5        | **public int available() throws IOException{}** 返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取的字节数。返回一个整数值。 |\n\n##### **FileOutputStream**\n\n```\n// 实例化法一\nOutputStream os = new FileOutputStream(\"E:/Miatum/Java.md\");\n// 实例化法二\nFile file = new File(\"E:/Miatum/Java.md\");\nOutputStream os = new FileOutputStream(\"E:/Miatum/Java.md\");\n```\n\n创建OutputStream 对象完成后，就可以使用下面的方法来写入流或者进行其他的流操作。\n\n| **序号** | **方法及描述**                                               |\n| :------- | :----------------------------------------------------------- |\n| 1        | **public void close() throws IOException{}** 关闭此文件输入流并释放与此流有关的所有系统资源。抛出IOException异常。 |\n| 2        | **protected void finalize()throws IOException {}** 这个方法清除与该文件的连接。确保在不再引用文件输入流时调用其 close 方法。抛出IOException异常。 |\n| 3        | **public void write(int w)throws IOException{}** 这个方法把指定的字节写到输出流中。 |\n| 4        | **public void write(byte[] w)** 把指定数组中w.length长度的字节写到OutputStream中。 |\n\n### 1.19 异常\n\n#### 常见异常分类\n\n- **检查性异常：**最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。\n- **运行时异常：** 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。\n- **错误：** 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。\n\n所有的异常类是从 `java.lang.Exception` 类继承的子类。\n\n`Exception` 类是 `Throwable` 类的子类。除了`Exception`类外，`Throwable`还有一个子类`Error` 。\n\n异常类有两个主要的子类：`IOException` 类和 `RuntimeException` 类。\n\n#### 非检查性异常\n\n| **异常**                        | **描述**                                                     |\n| :------------------------------ | :----------------------------------------------------------- |\n| ArithmeticException             | 当出现异常的运算条件时，抛出此异常。例如，一个整数\"除以零\"时，抛出此类的一个实例。 |\n| ArrayIndexOutOfBoundsException  | 用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。 |\n| ArrayStoreException             | 试图将错误类型的对象存储到一个对象数组时抛出的异常。         |\n| ClassCastException              | 当试图将对象强制转换为不是实例的子类时，抛出该异常。         |\n| IllegalArgumentException        | 抛出的异常表明向方法传递了一个不合法或不正确的参数。         |\n| IllegalMonitorStateException    | 抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。 |\n| IllegalStateException           | 在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。 |\n| IllegalThreadStateException     | 线程没有处于请求操作所要求的适当状态时抛出的异常。           |\n| IndexOutOfBoundsException       | 指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。 |\n| NegativeArraySizeException      | 如果应用程序试图创建大小为负的数组，则抛出该异常。           |\n| NullPointerException            | 当应用程序试图在需要对象的地方使用 `null` 时，抛出该异常     |\n| NumberFormatException           | 当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。 |\n| SecurityException               | 由安全管理器抛出的异常，指示存在安全侵犯。                   |\n| StringIndexOutOfBoundsException | 此异常由 `String` 方法抛出，指示索引或者为负，或者超出字符串的大小。 |\n| UnsupportedOperationException   | 当不支持请求的操作时，抛出该异常。                           |\n\n#### 检查性异常\n\n| **异常**                   | **描述**                                                     |\n| :------------------------- | :----------------------------------------------------------- |\n| ClassNotFoundException     | 应用程序试图加载类时，找不到相应的类，抛出该异常。           |\n| CloneNotSupportedException | 当调用 `Object` 类中的 `clone` 方法克隆对象，但该对象的类无法实现 `Cloneable` 接口时，抛出该异常。 |\n| IllegalAccessException     | 拒绝访问一个类的时候，抛出该异常。                           |\n| InstantiationException     | 当试图使用 `Class` 类中的 `newInstance` 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。 |\n| InterruptedException       | 一个线程被另一个线程中断，抛出该异常。                       |\n| NoSuchFieldException       | 请求的变量不存在                                             |\n| NoSuchMethodException      | 请求的方法不存在                                             |\n\n#### 异常方法\n\n下面的列表是 `Throwable` 类的主要方法:\n\n| **序号** | **方法及说明**                                               |\n| :------- | :----------------------------------------------------------- |\n| 1        | **public String getMessage()** 返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。 |\n| 2        | **public Throwable getCause()** 返回一个Throwable 对象代表异常原因。 |\n| 3        | **public String toString()** 使用getMessage()的结果返回类的串级名字。 |\n| 4        | **public void printStackTrace()** 打印toString()结果和栈层次到System.err，即错误输出流。 |\n| 5        | **public StackTraceElement [] getStackTrace()** 返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。 |\n| 6        | **public Throwable fillInStackTrace()** 用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。 |\n\n#### 捕获异常\n\n使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。\n\ntry/catch代码块中可以多次使用catch以捕获多个异常，即多重捕获。\n\n无论是否产生异常，finally中的语句始终会被执行。\n\ntry/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：\n\n```java\ntry {\n   // 程序代码\n} catch(ExceptionName e1) {\n   //Catch 块\n} finally {\n    System.out.println(\"无论是否产生异常，finally中的语句始终会被执行\");\n}\n```\n\n#### throws/throw 关键字：\n\n如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。\n\n也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。\n\n下面方法的声明抛出一个 RemoteException 异常：\n\n```java\nimport java.io.*; \npublic class className {  \n    public void deposit(double amount) throws RemoteException  {\n        // Method implementation    \n        throw new RemoteException();  \n    }  \n    //Remainder of class definition \n}\n```\n\n#### 自定义异常\n\n在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。\n\n- 所有异常都必须是 Throwable 的子类。\n- 如果希望写一个检查性异常类，则需要继承 Exception 类。\n- 如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。\n\n### 1.20 继承\n\n#### 特性\n\n- 子类拥有父类非 private 的属性、方法。\n- 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。\n- 子类可以用自己的方式实现父类的方法。\n- Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。\n- 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。\n\n#### 关键字\n\n继承可以使用 `extends` 和 `implements` 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承`object`（这个类在 **java.lang** 包中，所以不需要 **import**）祖先类。\n\n使用 `implements` 关键字可以变相的使java具有多继承的特性，**使用范围为类继承接口的情况**，可以**同时继承多个**接口（接口跟接口之间采用逗号分隔）。\n\n`super`关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。\n\n`this`关键字：指向自己的引用。\n\n`final` 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写。\n\n#### 构造器\n\n子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 **super** 关键字调用父类的构造器并配以适当的参数列表。\n\n如果父类构造器没有参数，则在子类的构造器中不需要使用 **super** 关键字调用父类构造器，系统会自动调用父类的无参构造器。\n\n```java\npackage base02;\n\nimport java.util.Date;\n\n/**\n * @Description\n * @ClassName Blog\n * @Author Miatum\n * @date 2021.03.25 23:16\n */\npublic class Blog {\n    // 子类具有父类的非private属性、方法\n    int id;\n    String title;\n    Date date;\n    String author;\n    String content;\n}\npublic class Article extends Blog {\n}\npublic class Music extends Blog {\n    private String resource_path;\n    public void transcoding() { }\n    public void play() {}\n}\npublic class Movie extends Blog {\n    private String resource_path;\n    public void transcoding() {}\n    public void play() {}\n}\n```\n\n### 1.21 重写/重载\n\n#### 重写(Override)\n\n重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。**即外壳不变，核心重写！**\n\n重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。\n\n重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。\n\n#### 方法的重写规则\n\n- 参数列表与被重写方法的参数列表必须完全相同。\n- 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。\n- 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。\n- 父类的成员方法只能被它的子类重写。\n- 声明为 final 的方法不能被重写。\n- 声明为 static 的方法不能被重写，但是能够被再次声明。\n- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。\n- 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。\n- 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。\n- 构造方法不能被重写。\n- 如果不能继承一个类，则不能重写该类的方法。\n\n#### 重载(Overload)\n\n重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。\n\n**重载最常见于类的构造方法，如无参构造方法和有参构造方法即为重载。**\n\n每个重载的方法（或者**构造函数**）都必须有一个独一无二的参数类型列表。\n\n最常用的地方就是构造器的重载。\n\n#### **重载规则**\n\n- 被重载的方法必须改变参数列表(参数个数或类型不一样)；\n- 被重载的方法可以改变返回类型；\n- 被重载的方法可以改变访问修饰符；\n- 被重载的方法可以声明新的或更广的检查异常；\n- 方法能够在同一个类中或者在一个子类中被重载。\n- 无法以返回值类型作为重载函数的区分标准。\n\n#### 重写与重载之间的区别\n\n| 区别点   | 重载方法 | 重写方法                                       |\n| :------- | :------- | :--------------------------------------------- |\n| 参数列表 | 必须修改 | 一定不能修改                                   |\n| 返回类型 | 可以修改 | 一定不能修改                                   |\n| 异常     | 可以修改 | 可以减少或删除，一定不能抛出新的或者更广的异常 |\n| 访问     | 可以修改 | 一定不能做更严格的限制（可以降低限制）         |\n\n### 1.22 多态\n\n多态性是对象多种表现形式的体现。\n\n#### 多态存在的三个必要条件\n\n- 继承\n- 重写\n- 向上转型：父类引用指向子类对象**Parent p = new Child();**\n\n### 1.23 抽象类\n\n- 抽象类不能实例化，只能实例化抽象类的子类。\n- 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。\n- 如果一个类包含抽象方法，那么该类必须是抽象类。\n- 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。\n- 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。\n- 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。\n\n### 1.24 封装\n\n#### 封装的优点\n\n- 良好的封装能够减少耦合。\n- 类内部的结构可以自由修改。\n- 可以对成员变量进行更精确的控制。\n- 隐藏信息，实现细节。\n\n#### 封装的实现\n\n1、修改属性的可见性来限制对属性的访问（一般限制为private）\n\n```java\npublic class User {\n    private int id;\n    private String name;\n}\n```\n\n2、对每个属性值提供对外的公共方法访问，即getter、setter方法。\n\n```java\npublic class User {\n    private int id;\n    private String name;\n    public int getId() {\n        return this.id;\n    }\n    public void setId(int id) {\n        this.id = id\n    }\n    public String name() {\n        return this.name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n```\n\n### 1.25 接口\n\n#### 接口与类的区别\n\n- 接口不能用于实例化对象。（抽象类也不能实例化对象）\n- 接口没有构造方法。\n- 接口中所有的方法必须是抽象方法。(接口方法自带隐式抽象，默认为public abstract)\n- 接口不能包含成员变量，除了 static 和 final 变量。\n- 接口不是被类继承了，而是要被类实现（类implements接口）。\n- 接口支持多继承（接口extends接口）。\n\n#### 特性\n\n- 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 **public abstract**（只能是 public abstract，其他修饰符都会报错）。\n- 接口中可以含有变量，但是接口中的变量会被隐式的指定为 **public static final** 变量（并且只能是 public，用 private 修饰会报编译错误）。\n- 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。\n\n#### 抽象类和接口的区别\n\n- 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。\n- 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 **public static final** 类型的。\n- 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。\n- 一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n- *注：JDK 1.8 以后，接口里可以有静态方法和方法体了。*\n\n#### 标记接口\n\n最常用的继承接口是没有包含任何方法的接口。\n\n标记接口是没有任何方法和属性的接口.**它仅仅表明实现该接口的类属于一个特定的类型**,供其他代码来测试允许做一些事情。\n\n**标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。**\n\n例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：\n\n```java\npackage java.util; \npublic interface EventListener {}\n```\n\n没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：\n\n- 建立一个公共的父接口：\n\n  正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。\n\n- 向一个类添加数据类型：\n\n  这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。\n\n#### 接口的继承\n\n```Java\npublic interface Hockey extends Sports{}\n```\n\n接口支持多继承\n\n```java\npublic interface Hockey extends Sports, Event{}\n```\n\n#### 接口的实现\n\n当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。\n\n```java\npublic class Dog implements Animal {\n    // 除非用abstract将Dog类定义为抽象类，否则Dog类需要实现Animal中的所有方法。\n}\n```\n\n### 1.26 枚举（enum）\n\nJava 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等。\n\nJava 枚举类使用 enum 关键字来定义，各个常量使用逗号 **,** 来分割。\n\n```java\n// 状态枚举类\nenum StateEnum {\n    NEW(0, \"新建\"), PRIVATE(1, \"保密\"), PUBLIC(2, \"公开\");\n    int stateId;\n    String stateName;\n    StateEnum(int stateId, String stateName) {\n        this.stateId = stateId;\n        this.stateName = stateName;\n    }\n    public String findName(int id) {\n        for (StateEnum s : StateEnum.values()) {\n            if (id == s.stateId) {\n                this.stateName = s.stateName;\n                break;\n            }\n        }\n        return this.stateName;\n    }\n}\n```\n\n### 1.27 包\n\n#### 包的作用\n\n- 1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。\n- 2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，**包可以避免名字冲突**。\n- 3、包也限定了**访问权限**，拥有包访问权限的类才能访问某个包中的类。\n\n### 1.28 数据结构\n\n在Java中的数据结构主要包括以下几种接口和类：\n\n- 枚举（Enumeration接口，方法有hasMoreElements和nextElement）\n- 位集合（BitSet）\n- 向量（Vector）\n- 栈（Stack）\n- 字典（Dictionary）\n- 哈希表（Hashtable）\n- 属性（Properties）\n- 集合（collection）\n\n| 序号 | 类描述                                                       |\n| :--- | :----------------------------------------------------------- |\n| 1    | Vector 该类和ArrayList非常相似，但是该类是同步的，可以用在多线程的情况，该类允许设置默认的增长长度，默认扩容方式为原来的2倍。 |\n| 2    | Stack 栈是Vector的一个子类，它实现了一个标准的后进先出的栈。 |\n| 3    | Dictionary Dictionary 类是一个抽象类，用来存储键/值对，作用和Map类相似。 |\n| 4    | Hashtable Hashtable 是 Dictionary(字典) 类的子类，位于 java.util 包中。 |\n| 5    | Properties Properties 继承于 Hashtable，表示一个持久的属性集，属性列表中每个键及其对应值都是一个字符串。 |\n| 6    | BitSet 一个Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。 |\n\n#### Enumeration 接口\n\n**源码**\n\n```java\npublic interface Enumeration<E> {\n    /**\n     * Tests if this enumeration contains more elements.\n     *\n     * @return  {@code true} if and only if this enumeration object\n     *           contains at least one more element to provide;\n     *          {@code false} otherwise.\n     */\n    boolean hasMoreElements();\n\n    /**\n     * Returns the next element of this enumeration if this enumeration\n     * object has at least one more element to provide.\n     *\n     * @return     the next element of this enumeration.\n     * @throws     NoSuchElementException  if no more elements exist.\n     */\n    E nextElement();\n\n    /**\n     * Returns an {@link Iterator} that traverses the remaining elements\n     * covered by this enumeration. Traversal is undefined if any methods\n     * are called on this enumeration after the call to {@code asIterator}.\n     *\n     * @apiNote\n     * This method is intended to help adapt code that produces\n     * {@code Enumeration} instances to code that consumes {@code Iterator}\n     * instances. For example, the {@link java.util.jar.JarFile#entries\n     * JarFile.entries()} method returns an {@code Enumeration<JarEntry>}.\n     * This can be turned into an {@code Iterator}, and then the\n     * {@code forEachRemaining()} method can be used:\n     *\n     * <pre>{@code\n     *     JarFile jarFile = ... ;\n     *     jarFile.entries().asIterator().forEachRemaining(entry -> { ... });\n     * }</pre>\n     *\n     * (Note that there is also a {@link java.util.jar.JarFile#stream\n     * JarFile.stream()} method that returns a {@code Stream} of entries,\n     * which may be more convenient in some cases.)\n     *\n     * @implSpec\n     * The default implementation returns an {@code Iterator} whose\n     * {@link Iterator#hasNext hasNext} method calls this Enumeration\'s\n     * {@code hasMoreElements} method, whose {@link Iterator#next next}\n     * method calls this Enumeration\'s {@code nextElement} method, and\n     * whose {@link Iterator#remove remove} method throws\n     * {@code UnsupportedOperationException}.\n     *\n     * @return an Iterator representing the remaining elements of this Enumeration\n     *\n     * @since 9\n     */\n    default Iterator<E> asIterator() {\n        return new Iterator<>() {\n            @Override public boolean hasNext() {\n                return hasMoreElements();\n            }\n            @Override public E next() {\n                return nextElement();\n            }\n        };\n    }\n}\n```\n\n可见，该接口主要有两个方法，hasMoreElements和nextElement。\n\n| 方法            | 返回值  | 说明                                           |\n| --------------- | ------- | ---------------------------------------------- |\n| hasMoreElements | Boolean | 当含有1个及以上元素时返回true，否则返回false。 |\n| nextElement     | E       | 使用了泛型，返回下一个包含的元素。             |\n\n#### Bitset 类\n\n**构造方法**\n\n```java\nBitSet bitset = new BitSet();\nBitSet bitSet = new BitSet(16); // 指定大小,参数为int类型\n```\n\n**其他方法**\n\n| 序号 | 方法描述                                                     |\n| :--- | :----------------------------------------------------------- |\n| 1    | void and(BitSet set) 对此目标位 set 和参数位 set 执行逻辑与操作。 |\n| 2    | void andNot(BitSet set) 清除此 BitSet 中所有的位，其相应的位在指定的 BitSet 中已设置。 |\n| 3    | int cardinality( ) 返回此 BitSet 中设置为 true 的位数。      |\n| 4    | void clear( ) 将此 BitSet 中的所有位设置为 false。           |\n| 5    | void clear(int index) 将索引指定处的位设置为 false。         |\n| 6    | void clear(int startIndex, int endIndex) 将指定的 startIndex（包括）到指定的 toIndex（不包括）范围内的位设置为 false。 |\n| 7    | Object clone( ) 复制此 BitSet，生成一个与之相等的新 BitSet。 |\n| 8    | boolean equals(Object bitSet) 将此对象与指定的对象进行比较。 |\n| 9    | void flip(int index) 将指定索引处的位设置为其当前值的补码。  |\n| 10   | void flip(int startIndex, int endIndex) 将指定的 fromIndex（包括）到指定的 toIndex（不包括）范围内的每个位设置为其当前值的补码。 |\n| 11   | boolean get(int index) 返回指定索引处的位值。                |\n| 12   | BitSet get(int startIndex, int endIndex) 返回一个新的 BitSet，它由此 BitSet 中从 fromIndex（包括）到 toIndex（不包括）范围内的位组成。 |\n| 13   | int hashCode( ) 返回此位 set 的哈希码值。                    |\n| 14   | boolean intersects(BitSet bitSet) 如果指定的 BitSet 中有设置为 true 的位，并且在此 BitSet 中也将其设置为 true，则返回 true。 |\n| 15   | boolean isEmpty( ) 如果此 BitSet 中没有包含任何设置为 true 的位，则返回 true。 |\n| 16   | int length( ) 返回此 BitSet 的\"逻辑大小\"：BitSet 中最高设置位的索引加 1。 |\n| 17   | int nextClearBit(int startIndex) 返回第一个设置为 false 的位的索引，这发生在指定的起始索引或之后的索引上。 |\n| 18   | int nextSetBit(int startIndex) 返回第一个设置为 true 的位的索引，这发生在指定的起始索引或之后的索引上。 |\n| 19   | void or(BitSet bitSet) 对此位 set 和位 set 参数执行逻辑或操作。 |\n| 20   | void set(int index) 将指定索引处的位设置为 true。            |\n| 21   | void set(int index, boolean v)  将指定索引处的位设置为指定的值。 |\n| 22   | void set(int startIndex, int endIndex) 将指定的 fromIndex（包括）到指定的 toIndex（不包括）范围内的位设置为 true。 |\n| 23   | void set(int startIndex, int endIndex, boolean v) 将指定的 fromIndex（包括）到指定的 toIndex（不包括）范围内的位设置为指定的值。 |\n| 24   | int size( ) 返回此 BitSet 表示位值时实际使用空间的位数。     |\n| 25   | String toString( ) 返回此位 set 的字符串表示形式。           |\n| 26   | void xor(BitSet bitSet) 对此位 set 和位 set 参数执行逻辑异或操作。 |\n\n#### Vector 类\n\nVector 主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。\n\n**构造方法**\n\n```java\nVector();\n// 创建指定大小的向量。\nVector(int size);\n// 第三种构造方法创建指定大小的向量，并且增量用 incr 指定。增量表示向量每次增加的元素数目。\nVector(int size, int incr);\n// 包含集合 c 元素的向量\nVector(Collection c);\n```\n\n| 序号 | 方法描述                                                     |\n| :--- | :----------------------------------------------------------- |\n| 1    | void add(int index, Object element)   在此向量的指定位置插入指定的元素。 |\n| 2    | boolean add(Object o)   将指定元素添加到此向量的末尾。       |\n| 3    | boolean addAll(Collection c)  将指定 Collection 中的所有元素添加到此向量的末尾，按照指定 collection 的迭代器所返回的顺序添加这些元素。 |\n| 4    | boolean addAll(int index, Collection c)  在指定位置将指定 Collection 中的所有元素插入到此向量中。 |\n| 5    | void addElement(Object obj)   将指定的组件添加到此向量的末尾，将其大小增加 1。 |\n| 6    | int capacity()  返回此向量的当前容量。                       |\n| 7    | void clear()  从此向量中移除所有元素。                       |\n| 8    | Object clone()  返回向量的一个副本。                         |\n| 9    | boolean contains(Object elem)  如果此向量包含指定的元素，则返回 true。 |\n| 10   | boolean containsAll(Collection c)  如果此向量包含指定 Collection 中的所有元素，则返回 true。 |\n| 11   | void copyInto(Object[] anArray)   将此向量的组件复制到指定的数组中。 |\n| 12   | Object elementAt(int index)  返回指定索引处的组件。          |\n| 13   | Enumeration elements()  返回此向量的组件的枚举。             |\n| 14   | void ensureCapacity(int minCapacity)  增加此向量的容量（如有必要），以确保其至少能够保存最小容量参数指定的组件数。 |\n| 15   | boolean equals(Object o)  比较指定对象与此向量的相等性。     |\n| 16   | Object firstElement()  返回此向量的第一个组件（位于索引 0) 处的项）。 |\n| 17   | Object get(int index)  返回向量中指定位置的元素。            |\n| 18   | int hashCode()  返回此向量的哈希码值。                       |\n| 19   | int indexOf(Object elem)   返回此向量中第一次出现的指定元素的索引，如果此向量不包含该元素，则返回 -1。 |\n| 20   | int indexOf(Object elem, int index)   返回此向量中第一次出现的指定元素的索引，从 index 处正向搜索，如果未找到该元素，则返回 -1。 |\n| 21   | void insertElementAt(Object obj, int index)  将指定对象作为此向量中的组件插入到指定的 index 处。 |\n| 22   | boolean isEmpty()  测试此向量是否不包含组件。                |\n| 23   | Object lastElement()  返回此向量的最后一个组件。             |\n| 24   | int lastIndexOf(Object elem)   返回此向量中最后一次出现的指定元素的索引；如果此向量不包含该元素，则返回 -1。 |\n| 25   | int lastIndexOf(Object elem, int index)  返回此向量中最后一次出现的指定元素的索引，从 index 处逆向搜索，如果未找到该元素，则返回 -1。 |\n| 26   | Object remove(int index)   移除此向量中指定位置的元素。      |\n| 27   | boolean remove(Object o)  移除此向量中指定元素的第一个匹配项，如果向量不包含该元素，则元素保持不变。 |\n| 28   | boolean removeAll(Collection c)  从此向量中移除包含在指定 Collection 中的所有元素。 |\n| 29   | void removeAllElements()  从此向量中移除全部组件，并将其大小设置为零。 |\n| 30   | boolean removeElement(Object obj)  从此向量中移除变量的第一个（索引最小的）匹配项。 |\n| 31   | void removeElementAt(int index)  删除指定索引处的组件。      |\n| 32   | protected void removeRange(int fromIndex, int toIndex) 从此 List 中移除其索引位于 fromIndex（包括）与 toIndex（不包括）之间的所有元素。 |\n| 33   | boolean retainAll(Collection c)  在此向量中仅保留包含在指定 Collection 中的元素。 |\n| 34   | Object set(int index, Object element)  用指定的元素替换此向量中指定位置处的元素。 |\n| 35   | void setElementAt(Object obj, int index)  将此向量指定 index 处的组件设置为指定的对象。 |\n| 36   | void setSize(int newSize)   设置此向量的大小。               |\n| 37   | int size()   返回此向量中的组件数。                          |\n| 38   | List subList(int fromIndex, int toIndex)  返回此 List 的部分视图，元素范围为从 fromIndex（包括）到 toIndex（不包括）。 |\n| 39   | Object[] toArray()  返回一个数组，包含此向量中以恰当顺序存放的所有元素。 |\n| 40   | Object[] toArray(Object[] a)  返回一个数组，包含此向量中以恰当顺序存放的所有元素；返回数组的运行时类型为指定数组的类型。 |\n| 41   | String toString()  返回此向量的字符串表示形式，其中包含每个元素的 String 表示形式。 |\n| 42   | void trimToSize()   对此向量的容量进行微调，使其等于向量的当前大小。 |\n\n#### Stack 类\n\n栈是Vector的一个子类，它实现了一个标准的后进先出的栈。\n\n堆栈只定义了**默认构造函数**，用来创建一个空栈。 堆栈除了包括由Vector定义的所有方法，也定义了自己的一些方法。\n\n| 序号 | 方法描述                                                     |\n| :--- | :----------------------------------------------------------- |\n| 1    | boolean empty()  测试堆栈是否为空。                          |\n| 2    | Object peek( ) 查看堆栈顶部的对象，但不从堆栈中移除它。      |\n| 3    | Object pop( ) 移除堆栈顶部的对象，并作为此函数的值返回该对象。 |\n| 4    | Object push(Object element) 把项压入堆栈顶部。               |\n| 5    | int search(Object element) 返回对象在堆栈中的位置，以 1 为基数。 |\n\n```java\nStack stack = new Stack();\npublic JavaStack() {\n    stack.add(\"spring\");\n    stack.add(\"summer\");\n    stack.add(\"autum\");\n    stack.add(\"winter\");\n}\n// 是否为空栈\npublic void empty() {\n    System.out.println(\"stack.empty():\" + stack.empty());\n}\n// 查看栈顶元素\npublic void peek() {\n    System.out.println(\"stack.peek():\" + stack.peek());\n}\n// 移除栈顶\npublic void pop() {\n    stack.pop();\n    System.out.println(\"stack.pop():\" + stack);\n}\n// 栈顶添加\npublic void push() {\n    stack.push(\"push item\");\n    System.out.println(\"stack.push():\" + stack);\n}\n// 返回值为4，即栈顶位置为1，栈底位置为stack.size()\npublic void search() {\n    System.out.println(\"stack.search():\" + stack.search(\"spring\"));\n}\n```\n\n#### Dictionary 类\n\nDictionary 类是一个**抽象类**，用来存储键/值对，作用和Map类相似。\n\nDictionary定义的抽象方法如下表所示：\n\n| **序号** | **方法描述**                                                 |\n| -------- | ------------------------------------------------------------ |\n| 1        | **Enumeration elements( )** 返回此 dictionary 中值的枚举。   |\n| 2        | **Object get(Object key)** 返回此 dictionary 中该键所映射到的值。 |\n| 3        | **boolean isEmpty( )** 测试此 dictionary 是否不存在从键到值的映射。 |\n| 4        | **Enumeration keys( )** 返回此 dictionary 中的键的枚举。     |\n| 5        | **Object put(Object key, Object value)** 将指定 key 映射到此 dictionary 中指定 value。 |\n| 6        | **Object remove(Object key)** 从此 dictionary 中移除 key （及其相应的 value）。 |\n| 7        | **int size( )** 返回此 dictionary 中条目（不同键）的数量。   |\n\n```java\nDictionary dict = new Hashtable();\npublic JavaDictionary() {\n    dict.put(1, \"C\");\n    dict.put(2, \"C++\");\n    dict.put(3, \"JAVA\");\n    dict.put(4, \"PHP\");\n    dict.put(5, \"SFDC\");\n}\n// 返回值的枚举\npublic void elements() {\n    for (Enumeration en = dict.elements(); en.hasMoreElements();) {\n        System.out.println(en.nextElement());\n    }\n}\n// 返回对应键的值\npublic void get() {\n    System.out.println(dict.get(1));\n}\n// 是否为空\npublic void isEmpty() {\n    System.out.println(dict.isEmpty());\n}\n// 返回键的枚举\npublic void keys() {\n    for (Enumeration en = dict.keys(); en.hasMoreElements();) {\n        System.out.println(en.nextElement());\n    }\n}\n// 添加键值对\npublic void put() {\n    dict.put(5, \"put value\");\n    System.out.println(dict);\n}\n// 获取大小\npublic void size() {\n    System.out.println(dict.size());\n}\n```\n\n#### Hashtable 类\n\n**继承关系**\n\n```java\nextends Dictionary<K,V>\nimplements Map<K,V>, Cloneable, java.io.Serializable\n```\n\n**构造方法**\n\n```java\nMap m = new HashMap();\nHashtable h1 = new Hashtable();\nHashtable h2 = new Hashtable(10);\nHashtable h3 = new Hashtable(10, 0.5f);\nHashtable h4 = new Hashtable(m);\n```\n\n**常用方法**\n\n| **序号** | **方法描述**                                                 |\n| :------- | :----------------------------------------------------------- |\n| 1        | **void clear( )**  将此哈希表清空，使其不包含任何键。        |\n| 2        | **Object clone( )** 创建此哈希表的浅表副本。                 |\n| 3        | **boolean contains(Object value)**  测试此映射表中是否存在与指定值关联的键。 |\n| 4        | **boolean containsKey(Object key)** 测试指定对象是否为此哈希表中的键。 |\n| 5        | **boolean containsValue(Object value)** 如果此 Hashtable 将一个或多个键映射到此值，则返回 true。 |\n| 6        | **Enumeration elements( )** 返回此哈希表中的值的枚举。       |\n| 7        | **Object get(Object key)**  返回指定键所映射到的值，如果此映射不包含此键的映射，则返回 null. 更确切地讲，如果此映射包含满足 (key.equals(k)) 的从键 k 到值 v 的映射，则此方法返回 v；否则，返回 null。 |\n| 8        | **boolean isEmpty( )** 测试此哈希表是否没有键映射到值。      |\n| 9        | **Enumeration keys( )**  返回此哈希表中的键的枚举。          |\n| 10       | **Object put(Object key, Object value)** 将指定 key 映射到此哈希表中的指定 value。 |\n| 11       | **void rehash( )** 增加此哈希表的容量并在内部对其进行重组，以便更有效地容纳和访问其元素。 |\n| 12       | **Object remove(Object key)** 从哈希表中移除该键及其相应的值。 |\n| 13       | **int size( )**  返回此哈希表中的键的数量。                  |\n| 14       | **String toString( )** 返回此 Hashtable 对象的字符串表示形式，其形式为 ASCII 字符 \", \" （逗号加空格）分隔开的、括在括号中的一组条目。 |\n\n#### Properties 类\n\n**继承关系**\n\n```Java\nextends Hashtable<Object,Object>\n```\n\n**构造方法**\n\n```java\nProperties propDefault = new Properties();\nProperties properties = new Properties(propDefault);\n```\n\n除了从 Hashtable 中所定义的方法，Properties 还定义了以下方法：\n\n| **序号** | **方法描述**                                                 |\n| :------- | :----------------------------------------------------------- |\n| 1        | **String getProperty(String key)**  用指定的键在此属性列表中搜索属性。 |\n| 2        | **String getProperty(String key, String defaultProperty)** 用指定的键在属性列表中搜索属性。 |\n| 3        | **void list(PrintStream streamOut)**  将属性列表输出到指定的输出流。 |\n| 4        | **void list(PrintWriter streamOut)** 将属性列表输出到指定的输出流。 |\n| 5        | **void load(InputStream streamIn) throws IOException**  从输入流中读取属性列表（键和元素对）。 |\n| 6        | **Enumeration propertyNames( )** 按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）。 |\n| 7        | **Object setProperty(String key, String value)**  调用 Hashtable 的方法 put。 |\n| 8        | **void store(OutputStream streamOut, String description)**  以适合使用 load(InputStream)方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。 |\n\n### 1.29 集合框架\n\n#### 框架图\n\n![img](https://www.runoob.com/wp-content/uploads/2014/01/2243690-9cd9c896e0d512ed.gif)\n\n#### 集合接口\n\n| 序号 | 接口描述                                                     |\n| :--- | :----------------------------------------------------------- |\n| 1    | Collection 接口 Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和set)。Collection 接口存储一组不唯一，无序的对象。 |\n| 2    | List 接口 List接口是一个有序的 Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引(元素在List中位置，类似于数组的下标)来访问List中的元素，第一个元素的索引为 0，而且允许有相同的元素。List 接口存储一组不唯一，有序（插入顺序）的对象。 |\n| 3    | Set Set 具有与 Collection 完全一样的接口，只是行为上不同，Set 不保存重复的元素。Set 接口存储一组唯一，无序的对象。 |\n| 4    | SortedSet 继承于Set保存有序的集合。                          |\n| 5    | Map Map 接口存储一组键值对象，提供key（键）到value（值）的映射。 |\n| 6    | Map.Entry 描述在一个Map中的一个元素（键/值对）。是一个 Map 的内部接口。 |\n| 7    | SortedMap 继承于 Map，使 Key 保持在升序排列。                |\n| 8    | Enumeration 这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。 |\n\n#### Set和List的区别\n\n- Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。\n- Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 **<实现类有HashSet,TreeSet>**。\n- List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 **<实现类有ArrayList,LinkedList,Vector>** 。\n\n#### 集合实现类\n\n| 序号 | 类描述                                                       |\n| :--- | :----------------------------------------------------------- |\n| 1    | **AbstractCollection**  实现了大部分的集合接口。             |\n| 2    | **AbstractList**  继承于AbstractCollection 并且实现了大部分List接口。 |\n| 3    | **AbstractSequentialList**  继承于 AbstractList ，提供了对数据元素的链式访问而不是随机访问。 |\n| 4    | [LinkedList](https://www.runoob.com/java/java-linkedlist.html) 该类实现了List接口，允许有null（空）元素。主要用于创建链表数据结构，该类没有同步方法，如果多个线程同时访问一个List，则必须自己实现访问同步，解决方法就是在创建List时候构造一个同步的List。例如：`List list=Collections.synchronizedList(newLinkedList(...));`LinkedList 查找效率低。 |\n| 5    | [ArrayList](https://www.runoob.com/java/java-arraylist.html) 该类也是实现了List的接口，实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。该类也是非同步的,在多线程的情况下不要使用。ArrayList 增长当前长度的50%，插入删除效率低。 |\n| 6    | **AbstractSet**  继承于AbstractCollection 并且实现了大部分Set接口。 |\n| 7    | [HashSet](https://www.runoob.com/java/java-hashset.html) 该类实现了Set接口，不允许出现重复元素，不保证集合中元素的顺序，允许包含值为null的元素，但最多只能一个。 |\n| 8    | LinkedHashSet 具有可预知迭代顺序的 `Set` 接口的哈希表和链接列表实现。 |\n| 9    | TreeSet 该类实现了Set接口，可以实现排序等功能。              |\n| 10   | **AbstractMap**  实现了大部分的Map接口。                     |\n| 11   | [HashMap](https://www.runoob.com/java/java-hashmap.html) HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。 该类实现了Map接口，根据键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步。 |\n| 12   | TreeMap 继承了AbstractMap，并且使用一颗树。                  |\n| 13   | WeakHashMap 继承AbstractMap类，使用弱密钥的哈希表。          |\n| 14   | LinkedHashMap 继承于HashMap，使用元素的自然顺序对元素进行排序. |\n| 15   | IdentityHashMap 继承AbstractMap类，比较文档时使用引用相等。  |\n\n#### ArrayList\n\nArrayList 继承了 AbstractList ，并实现了 List 接口。\n\n**常用方法**\n\n```java\n// 初始化\nArrayList<String> arr = new ArrayList();\n// get element\narr.get(0);\n// add element\narr.add(\"miatum\");\n// delete element\narr.remove(0);\n// update element\narr.set(0, \"new value\");\n// get size\narr.size();\n// traversal with for\nfor (int i = 0; i < arr.size(); i++) {\n    System.out.println(arr.get(i));\n}\n// traversal with enhanced for\nfor (String temp : arr) {\n    System.out.println(temp);\n}\n// traversal with iterator\nIterator it = arr.iterator();\nwhile (it.hasNext()) {\n    System.out.println(it.next());\n}\n// sort\nCollections.sort(arr);\n```\n\nJava ArrayList 常用方法列表如下：\n\n| 方法                                                         | 描述                                          |\n| :----------------------------------------------------------- | :-------------------------------------------- |\n| [add()](https://www.runoob.com/java/java-arraylist-add.html) | 将元素插入到指定位置的 arraylist 中           |\n| [addAll()](https://www.runoob.com/java/java-arraylist-addall.html) | 添加集合中的所有元素到 arraylist 中           |\n| [clear()](https://www.runoob.com/java/java-arraylist-clear.html) | 删除 arraylist 中的所有元素                   |\n| [clone()](https://www.runoob.com/java/java-arraylist-clone.html) | 复制一份 arraylist                            |\n| [contains()](https://www.runoob.com/java/java-arraylist-contains.html) | 判断元素是否在 arraylist                      |\n| [get()](https://www.runoob.com/java/java-arraylist-get.html) | 通过索引值获取 arraylist 中的元素             |\n| [indexOf()](https://www.runoob.com/java/java-arraylist-indexof.html) | 返回 arraylist 中元素的索引值                 |\n| [removeAll()](https://www.runoob.com/java/java-arraylist-removeall.html) | 删除存在于指定集合中的 arraylist 里的所有元素 |\n| [remove()](https://www.runoob.com/java/java-arraylist-remove.html) | 删除 arraylist 里的单个元素                   |\n| [size()](https://www.runoob.com/java/java-arraylist-size.html) | 返回 arraylist 里元素数量                     |\n| [isEmpty()](https://www.runoob.com/java/java-arraylist-isempty.html) | 判断 arraylist 是否为空                       |\n| [subList()](https://www.runoob.com/java/java-arraylist-sublist.html) | 截取部分 arraylist 的元素                     |\n| [set()](https://www.runoob.com/java/java-arraylist-set.html) | 替换 arraylist 中指定索引的元素               |\n| [sort()](https://www.runoob.com/java/java-arraylist-sort.html) | 对 arraylist 元素进行排序                     |\n| [toArray()](https://www.runoob.com/java/java-arraylist-toarray.html) | 将 arraylist 转换为数组                       |\n| [toString()](https://www.runoob.com/java/java-arraylist-tostring.html) | 将 arraylist 转换为字符串                     |\n| [ensureCapacity](https://www.runoob.com/java/java-arraylist-surecapacity.html)() | 设置指定容量大小的 arraylist                  |\n| [lastIndexOf()](https://www.runoob.com/java/java-arraylist-lastindexof.html) | 返回指定元素在 arraylist 中最后一次出现的位置 |\n| [retainAll()](https://www.runoob.com/java/java-arraylist-retainall.html) | 保留 arraylist 中在指定集合中也存在的那些元素 |\n| [containsAll()](https://www.runoob.com/java/java-arraylist-containsall.html) | 查看 arraylist 是否包含指定集合中的所有元素   |\n| [trimToSize()](https://www.runoob.com/java/java-arraylist-trimtosize.html) | 将 arraylist 中的容量调整为数组中的元素个数   |\n| [removeRange()](https://www.runoob.com/java/java-arraylist-removerange.html) | 删除 arraylist 中指定索引之间存在的元素       |\n| [replaceAll()](https://www.runoob.com/java/java-arraylist-replaceall.html) | 将给定的操作内容替换掉数组中每一个元素        |\n| [removeIf()](https://www.runoob.com/java/java-arraylist-removeif.html) | 删除所有满足特定条件的 arraylist 元素         |\n| [forEach()](https://www.runoob.com/java/java-arraylist-foreach.html) | 遍历 arraylist 中每一个元素并执行特定操作     |\n\n#### LinkedList\n\n链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。\n\n链表可分为单向链表和双向链表。\n\n一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。\n\n一个双向链表有三个整数值: 数值、向后的节点链接、向前的节点链接。\n\nJava LinkedList（链表） 类似于 ArrayList，是一种常用的数据容器。\n\n与 ArrayList 相比，LinkedList 的增加和删除对操作效率更高，而查找和修改的操作效率较低。\n\n**以下情况使用 ArrayList :**\n\n- 频繁访问列表中的某一个元素。\n- 只需要在列表末尾进行添加和删除元素操作。\n\n**以下情况使用 LinkedList :**\n\n- 你需要通过循环迭代来访问列表中的某些元素。\n- 需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。\n\nLinkedList 继承了 AbstractSequentialList 类。\n\nLinkedList 实现了 Queue 接口，可作为队列使用。\n\nLinkedList 实现了 List 接口，可进行列表的相关操作。\n\nLinkedList 实现了 Deque 接口，可作为队列使用。\n\nLinkedList 实现了 Cloneable 接口，可实现克隆。\n\nLinkedList 实现了 java.io.Serializable 接口，即可支持序列化，能通过序列化去传输。\n\n```java\nimport java.util.LinkedList;\n// 初始化\nLinkedList<String> ll = new LinkedList<String>();\nLinkedList<String> ll = new LinkedList(<? extends String> c);\n// add element\nll.add(\"miatum\");\n```\n\n**常用方法**\n\n| 方法                                           | 描述                                                         |\n| :--------------------------------------------- | :----------------------------------------------------------- |\n| public boolean add(E e)                        | 链表末尾添加元素，返回是否成功，成功为 true，失败为 false。  |\n| public void add(int index, E element)          | 向指定位置插入元素。                                         |\n| public boolean addAll(Collection c)            | 将一个集合的所有元素添加到链表后面，返回是否成功，成功为 true，失败为 false。 |\n| public boolean addAll(int index, Collection c) | 将一个集合的所有元素添加到链表的指定位置后面，返回是否成功，成功为 true，失败为 false。 |\n| public void addFirst(E e)                      | 元素添加到头部。                                             |\n| public void addLast(E e)                       | 元素添加到尾部。                                             |\n| public boolean offer(E e)                      | 向链表末尾添加元素，返回是否成功，成功为 true，失败为 false。 |\n| public boolean offerFirst(E e)                 | 头部插入元素，返回是否成功，成功为 true，失败为 false。      |\n| public boolean offerLast(E e)                  | 尾部插入元素，返回是否成功，成功为 true，失败为 false。      |\n| public void clear()                            | 清空链表。                                                   |\n| public E removeFirst()                         | 删除并返回第一个元素。                                       |\n| public E removeLast()                          | 删除并返回最后一个元素。                                     |\n| public boolean remove(Object o)                | 删除某一元素，返回是否成功，成功为 true，失败为 false。      |\n| public E remove(int index)                     | 删除指定位置的元素。                                         |\n| public E poll()                                | 删除并返回第一个元素。                                       |\n| public E remove()                              | 删除并返回第一个元素。                                       |\n| public boolean contains(Object o)              | 判断是否含有某一元素。                                       |\n| public E get(int index)                        | 返回指定位置的元素。                                         |\n| public E getFirst()                            | 返回第一个元素。                                             |\n| public E getLast()                             | 返回最后一个元素。                                           |\n| public int indexOf(Object o)                   | 查找指定元素从前往后第一次出现的索引。                       |\n| public int lastIndexOf(Object o)               | 查找指定元素最后一次出现的索引。                             |\n| public E peek()                                | 返回第一个元素。                                             |\n| public E element()                             | 返回第一个元素。                                             |\n| public E peekFirst()                           | 返回头部元素。                                               |\n| public E peekLast()                            | 返回尾部元素。                                               |\n| public E set(int index, E element)             | 设置指定位置的元素。                                         |\n| public Object clone()                          | 克隆该列表。                                                 |\n| public Iterator descendingIterator()           | 返回倒序迭代器。                                             |\n| public int size()                              | 返回链表元素个数。                                           |\n| public ListIterator listIterator(int index)    | 返回从指定位置开始到末尾的迭代器。                           |\n| public Object[] toArray()                      | 返回一个由链表元素组成的数组。                               |\n| public T[] toArray(T[] a)                      | 返回一个由链表元素转换类型而成的数组。                       |\n\n#### HashSet\n\nHashSet 基于 HashMap 来实现的，是一个**不允许有重复元素**的集合。\n\nHashSet 允许有 null 值。\n\nHashSet 是**无序**的，即不会记录插入的顺序。\n\nHashSet 不是线程安全的， 如果多个线程尝试同时修改 HashSet，则最终结果是不确定的。 您必须在多线程访问时显式同步对 HashSet 的并发访问。\n\nHashSet 实现了 Set 接口。\n\n```java\nimport java.util.HashSet;\n// init\nHashSet<String> sites = new HashSet<String>();\nsites.add(); // 可以添加null\nsites.add(\"miatum\");\nsites.add(\"miatum\"); // 不会添加重复值\nsites.contains(\"miatum\"); // true\nsites.remove(\"miatum\");\nsites.clear(); // 清除集合所有元素\nsites.size();\nfor(String i : sites) {\n    System.out.println(i); // 增强for循环\n}\n```\n\n#### HashMap\n\nHashMap 是一个散列表，它存储的内容是键值对(key-value)映射。\n\nHashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。\n\nHashMap 是无序的，即不会记录插入的顺序。\n\nHashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。\n\nHashMap中的元素是对象，如果需要用到基本数据类型作为元素时，改为用其包装类对象。\n\n```java\nimport java.util.HashMap;\nHashMap<Integer, String> sites = new HashMap<Integer, String>();\nsites.put(1, \"Google\"); //add element\nsites.get(1); // 通过key值获取value\nsites.remobe(1); // 通过key值删除元素\nsites.clear(); // 删除所有元素\nsites.size(); // 大小\n// 遍历\nfor (Integer i : sites.keySet()) {\n    System.out.println(sites.get(i));\n}\nfor (String value : sites.values()) {\n    System.out.println(value);\n}\n```\n\n#### 常用方法\n\n| 方法                                                         | 描述                                                         |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [clear()](https://www.runoob.com/java/java-hashmap-clear.html) | 删除 hashMap 中的所有键/值对                                 |\n| [clone()](https://www.runoob.com/java/java-hashmap-clone.html) | 复制一份 hashMap                                             |\n| [isEmpty()](https://www.runoob.com/java/java-hashmap-isempty.html) | 判断 hashMap 是否为空                                        |\n| [size()](https://www.runoob.com/java/java-hashmap-size.html) | 计算 hashMap 中键/值对的数量                                 |\n| [put()](https://www.runoob.com/java/java-hashmap-put.html)   | 将键/值对添加到 hashMap 中                                   |\n| [putAll()](https://www.runoob.com/java/java-hashmap-putall.html) | 将所有键/值对添加到 hashMap 中                               |\n| [putIfAbsent()](https://www.runoob.com/java/java-hashmap-putifabsent.html) | 如果 hashMap 中不存在指定的键，则将指定的键/值对插入到 hashMap 中。 |\n| [remove()](https://www.runoob.com/java/java-hashmap-remove.html) | 删除 hashMap 中指定键 key 的映射关系                         |\n| [containsKey()](https://www.runoob.com/java/java-hashmap-containskey.html) | 检查 hashMap 中是否存在指定的 key 对应的映射关系。           |\n| [containsValue()](https://www.runoob.com/java/java-hashmap-containsvalue.html) | 检查 hashMap 中是否存在指定的 value 对应的映射关系。         |\n| [replace()](https://www.runoob.com/java/java-hashmap-replace.html) | 替换 hashMap 中是指定的 key 对应的 value。                   |\n| [replaceAll()](https://www.runoob.com/java/java-hashmap-replaceall.html) | 将 hashMap 中的所有映射关系替换成给定的函数所执行的结果。    |\n| [get()](https://www.runoob.com/java/java-hashmap-get.html)   | 获取指定 key 对应对 value                                    |\n| [getOrDefault()](https://www.runoob.com/java/java-hashmap-getordefault.html) | 获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值 |\n| [forEach()](https://www.runoob.com/java/java-hashmap-foreach.html) | 对 hashMap 中的每个映射执行指定的操作。                      |\n| [entrySet()](https://www.runoob.com/java/java-hashmap-entryset.html) | 返回 hashMap 中所有映射项的集合集合视图。                    |\n| [keySet](https://www.runoob.com/java/java-hashmap-keyset.html)() | 返回 hashMap 中所有 key 组成的集合视图。                     |\n| [values()](https://www.runoob.com/java/java-hashmap-values.html) | 返回 hashMap 中存在的所有 value 值。                         |\n| [merge()](https://www.runoob.com/java/java-hashmap-merge.html) | 添加键值对到 hashMap 中                                      |\n| [compute()](https://www.runoob.com/java/java-hashmap-compute.html) | 对 hashMap 中指定 key 的值进行重新计算                       |\n| [computeIfAbsent()](https://www.runoob.com/java/java-hashmap-computeifabsent.html) | 对 hashMap 中指定 key 的值进行重新计算，如果不存在这个 key，则添加到 hasMap 中 |\n| [computeIfPresent()](https://www.runoob.com/java/java-hashmap-computeifpresent.html) | 对 hashMap 中指定 key 的值进行重新计算，前提是该 key 存在于 hashMap 中。 |\n\n### 1.30 迭代器\n\nJava Iterator（迭代器）不是一个集合，它是一种用于访问集合的方法，可用于迭代 [ArrayList](https://www.runoob.com/java/java-arraylist.html) 和 [HashSet](https://www.runoob.com/java/java-hashset.html) 等集合。\n\nIterator 是 Java 迭代器最简单的实现，ListIterator 是 Collection API 中的接口， 它扩展了 Iterator 接口。\n\n迭代器 it 的两个基本操作是 next 、hasNext 和 remove。\n\n调用 it.next() 会返回迭代器的下一个元素，并且更新迭代器的状态。\n\n调用 it.hasNext() 用于检测集合中是否还有元素。\n\n调用 it.remove() 将迭代器返回的元素删除。\n\n```java\n// 引入 ArrayList 和 Iterator 类\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class RunoobTest {\n    public static void main(String[] args) {\n\n        // 创建集合\n        ArrayList<String> sites = new ArrayList<String>();\n        sites.add(\"Google\");\n        sites.add(\"Runoob\");\n        sites.add(\"Taobao\");\n        sites.add(\"Zhihu\");\n\n        // 获取迭代器\n        Iterator<String> it = sites.iterator();\n\n        // 输出集合中的第一个元素\n        System.out.println(it.next());\n    }\n}\n```\n\n### 1.31 Object类\n\nJava Object 类是所有类的父类，也就是说 Java 的所有类都继承了 Object，**子类可以使用 Object 的所有方法**。\n\n#### 方法\n\n| 序号 | 方法 & 描述                                                  |\n| :--- | :----------------------------------------------------------- |\n| 1    | [protected Object clone()](https://www.runoob.com/java/java-object-clone.html)创建并返回一个对象的拷贝 |\n| 2    | [boolean equals(Object obj)](https://www.runoob.com/java/java-object-equals.html)比较两个对象是否相等 |\n| 3    | [protected void finalize()](https://www.runoob.com/java/java-object-finalize.html)当 GC (垃圾回收器)确定不存在对该对象的有更多引用时，由对象的垃圾回收器调用此方法。 |\n| 4    | [Class getClass()](https://www.runoob.com/java/java-object-getclass.html)获取对象的运行时对象的类 |\n| 5    | [int hashCode()](https://www.runoob.com/java/java-object-hashcode.html)获取对象的 hash 值 |\n| 6    | [void notify()](https://www.runoob.com/java/java-object-notify.html)唤醒在该对象上等待的某个线程 |\n| 7    | [void notifyAll()](https://www.runoob.com/java/java-object-notifyall.html)唤醒在该对象上等待的所有线程 |\n| 8    | [String toString()](https://www.runoob.com/java/java-object-tostring.html)返回对象的字符串表示形式 |\n| 9    | [void wait()](https://www.runoob.com/java/java-object-wait.html)让当前线程进入等待状态。直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。 |\n| 10   | [void wait(long timeout)](https://www.runoob.com/java/java-object-wait-timeout.html)让当前线程处于等待(阻塞)状态，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过参数设置的timeout超时时间。 |\n| 11   | [void wait(long timeout, int nanos)](https://www.runoob.com/java/java-object-wait-nanos.html)与 wait(long timeout) 方法类似，多了一个 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。 |\n\n### 1.32 泛型\n\nJava 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。\n\n泛型的本质是**参数化类型**，也就是说所操作的数据类型被指定为一个参数。\n\n#### 泛型方法\n\n定义泛型方法的规则：\n\n- 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的<E>）。\n- 每一个类型参数声明部分包含**一个或多个类型参数**，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。\n- 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。\n- 泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像int,double,char的等）。\n\n```java\n// 打印数组的泛型方法\npublic static <T> void printArray(T[] arr) {\n    for (T element : arr) {\n        System.out.println(element);\n    }\n}\n```\n\n**有界的类型参数:**\n\n可能有时候，你会想限制那些被允许传递到一个类型参数的类型种类范围。例如，一个操作数字的方法可能只希望接受Number或者Number子类的实例。这就是有界类型参数的目的。\n\n要声明一个有界的类型参数，首先列出类型参数的名称，后跟extends关键字，最后紧跟它的上界。\n\n```java\n// 多个限制上界（与关系）, 因为Java是单继承机制，类上界只有一个写在第一个，而后写接口上界\npublic static <T extends Blog & Cloneable & Serializable> void multiLimited(T o) {\n    System.out.println(o.getClass());\n}\n```\n\n#### 泛型类\n\n泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。\n\n和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。\n\n**Java常见泛型类**：ArrayList、HashMap\n\n#### 类型通配符\n\n1、类型通配符一般是使用?代替具体的类型参数。例如 **List** 在逻辑上是**List,List** 等所有List<具体类型实参>的父类。\n\n2、类型通配符上限通过形如List来定义，如此定义就是通配符泛型值接受Number及其下层子类类型。\n\n3、类型通配符下限通过形如 **List**来定义，表示类型只能接受Number及其三层父类类型，如 Object 类型的实例。\n\n### 1.33 序列化\n\nJava 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。\n\n将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。\n\n整个过程都是 Java 虚拟机（JVM）独立的，也就是说，**在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象**。(可以理解为转码再解码)\n\n类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含反序列化和序列化对象的方法。\n\n请注意，一个类的对象要想序列化成功，必须满足**两个条件**：\n\n**该类必须实现 java.io.Serializable 接口**。\n\n该类的**所有属性必须是可序列化**的。如果有一个属性不是可序列化的，则该属性必须注明是**短暂**的。\n\n### 1.34 网络编程\n\n网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。\n\njava.net 包中 J2SE 的 API 包含有类和接口，它们提供低层次的通信细节。你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。\n\njava.net 包中提供了两种常见的网络协议的支持：\n\n- **TCP**：TCP（英语：Transmission Control Protocol，传输控制协议） 是一种面向连接的、可靠的、基于字节流的传输层通信协议，TCP 层是位于 IP 层之上，应用层之下的中间层。TCP 保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP / IP。\n- **UDP**：UDP （英语：User Datagram Protocol，用户数据报协议），位于 OSI 模型的传输层。一个无连接的协议。提供了应用程序之间要发送数据的数据报。由于UDP缺乏可靠性且属于无连接协议，所以应用程序通常必须容许一些丢失、错误或重复的数据包。\n\n#### Socket 编程\n\n套接字使用TCP提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字。\n\n当连接建立时，服务器会创建一个 Socket 对象。客户端和服务器现在可以通过对 Socket 对象的写入和读取来进行通信。\n\njava.net.Socket 类代表一个套接字，并且 java.net.ServerSocket 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。\n\n以下步骤在两台计算机之间使用套接字建立TCP连接时会出现：\n\n- 服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。\n- 服务器调用 ServerSocket 类的 accept() 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。\n- 服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。\n- Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。\n- 在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该 socket 连接到客户端的 socket。\n\n连接建立后，通过使用 I/O 流在进行通信，每一个socket都有一个输出流和一个输入流，客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流。\n\nTCP 是一个双向的通信协议，因此数据可以通过两个数据流在同一时间发送.以下是一些类提供的一套完整的有用的方法来实现 socket。\n\n服务器应用程序通过使用 java.net.ServerSocket 类以获取一个端口,并且侦听客户端请求。\n\n#### ServerSocket 类构造方法\n\n| **序号** | **方法描述**                                                 |\n| -------- | ------------------------------------------------------------ |\n| 1        | **public ServerSocket(int port) throws IOException** 创建绑定到特定端口的服务器套接字。 |\n| 2        | **public ServerSocket(int port, int backlog) throws IOException** 利用指定的 backlog 创建服务器套接字并将其绑定到指定的本地端口号。 |\n| 3        | **public ServerSocket(int port, int backlog, InetAddress address) throws IOException** 使用指定的端口、侦听 backlog 和要绑定到的本地 IP 地址创建服务器。 |\n| 4        | **public ServerSocket() throws IOException** 创建非绑定服务器套接字。 |\n\n#### ServerSocket 常用方法\n\n| **序号** | **方法描述**                                                 |\n| -------- | ------------------------------------------------------------ |\n| 1        | **public int getLocalPort()**  返回此套接字在其上侦听的端口。 |\n| 2        | **public Socket accept() throws IOException** 侦听并接受到此套接字的连接。 |\n| 3        | **public void setSoTimeout(int timeout)**  通过指定超时值启用/禁用 SO_TIMEOUT，以毫秒为单位。 |\n| 4        | **public void bind(SocketAddress host, int backlog)** 将 ServerSocket 绑定到特定地址（IP 地址和端口号）。 |\n\njava.net.Socket 类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个 Socket 对象通过实例化 ，而 服务器获得一个 Socket 对象则通过 accept() 方法的返回值。\n\n#### Socket 类构造方法\n\n| **序号** | **方法描述**                                                 |\n| -------- | ------------------------------------------------------------ |\n| 1        | **public Socket(String host, int port) throws UnknownHostException, IOException.** 创建一个流套接字并将其连接到指定主机上的指定端口号。 |\n| 2        | **public Socket(InetAddress host, int port) throws IOException** 创建一个流套接字并将其连接到指定 IP 地址的指定端口号。 |\n| 3        | **public Socket(String host, int port, InetAddress localAddress, int localPort) throws IOException.** 创建一个套接字并将其连接到指定远程主机上的指定远程端口。 |\n| 4        | **public Socket(InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException.** 创建一个套接字并将其连接到指定远程地址上的指定远程端口。 |\n| 5        | **public Socket()** 通过系统默认类型的 SocketImpl 创建未连接套接字 |\n\n#### Socket 类常用方法\n\n| **序号** | **方法描述**                                                 |\n| -------- | ------------------------------------------------------------ |\n| 1        | **public void connect(SocketAddress host, int timeout) throws IOException** 将此套接字连接到服务器，并指定一个超时值。 |\n| 2        | **public InetAddress getInetAddress()**  返回套接字连接的地址。 |\n| 3        | **public int getPort()** 返回此套接字连接到的远程端口。      |\n| 4        | **public int getLocalPort()** 返回此套接字绑定到的本地端口。 |\n| 5        | **public SocketAddress getRemoteSocketAddress()** 返回此套接字连接的端点的地址，如果未连接则返回 null。 |\n| 6        | **public InputStream getInputStream() throws IOException** 返回此套接字的输入流。 |\n| 7        | **public OutputStream getOutputStream() throws IOException** 返回此套接字的输出流。 |\n| 8        | **public void close() throws IOException** 关闭此套接字。    |\n\n#### InetAddress 类方法\n\n这个类表示互联网协议(IP)地址。下面列出了 Socket 编程时比较有用的方法：\n\n| **序号** | **方法描述**                                                 |\n| -------- | ------------------------------------------------------------ |\n| 1        | **static InetAddress getByAddress(byte[] addr)** 在给定原始 IP 地址的情况下，返回 InetAddress 对象。 |\n| 2        | **static InetAddress getByAddress(String host, byte[] addr)** 根据提供的主机名和 IP 地址创建 InetAddress。 |\n| 3        | **static InetAddress getByName(String host)** 在给定主机名的情况下确定主机的 IP 地址。 |\n| 4        | **String getHostAddress()**  返回 IP 地址字符串（以文本表现形式）。 |\n| 5        | **String getHostName()**   获取此 IP 地址的主机名。          |\n| 6        | **static InetAddress getLocalHost()** 返回本地主机。         |\n| 7        | **String toString()** 将此 IP 地址转换为 String。            |\n\n```java\n/**\n * @Description\n * @ClassName Client socket客户端\n * @Author Miatum\n * @date 2021.04.08 15:42\n */\npublic class Client {\n    public static void main(String[] args) {\n        String serverName = args[0];\n        int port = Integer.parseInt(args[1]);\n        try {\n            System.out.println(\"连接到主机：\" + serverName + \" ，端口号：\" + port);\n            Socket client = new Socket(serverName, port);\n            System.out.println(\"主机地址：\" + client.getRemoteSocketAddress());\n            OutputStream outToServer = client.getOutputStream();\n            DataOutputStream out = new DataOutputStream(outToServer);\n            out.writeUTF(\"Hello from \" + client.getLocalSocketAddress());\n            InputStream infromServer = client.getInputStream();\n            DataInputStream in = new DataInputStream(infromServer);\n            System.out.println(\"服务器响应：\" + in.readUTF());\n            client.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n```java\n/**\n * @Description\n * @ClassName Server socket服务器端\n * @Author Miatum\n * @date 2021.04.08 15:42\n */\npublic class Server extends Thread {\n    private ServerSocket serverSocket;\n    public Server(int port) throws IOException {\n        serverSocket = new ServerSocket(port);\n        serverSocket.setSoTimeout(10000);\n    }\n    public void run() {\n        while(true) {\n            try {\n                System.out.println(\"等待远程连接，端口号为：\" + serverSocket.getLocalPort() + \"...\");\n                Socket server = serverSocket.accept();\n                System.out.println(\"远程主机地址：\" + server.getRemoteSocketAddress());\n                DataInputStream in = new DataInputStream(server.getInputStream());\n                System.out.println(in.readUTF());\n                DataOutputStream out = new DataOutputStream(server.getOutputStream());\n                out.writeUTF(\"谢谢连接我：\" + server.getLocalSocketAddress() + \"\\nGoodbye!\");\n                server.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    public static void main(String[] args) {\n        int port = Integer.parseInt(args[0]);\n        try {\n            Thread t = new Server(port);\n            t.run();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n### 1.35 邮件\n\n配置依赖\n\n```java\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-mail</artifactId>\n</dependency>\n```\n\n配置application.properties\n\n```java\n#邮箱\nspring.mail.host=smtp.qq.com\nspring.mail.username=443398600@qq.com\nspring.mail.default-encoding=utf-8\n#邮箱开启POP3/SMTP服务授权码\nspring.mail.password=birpyrblsoiubjda\n```\n\n![image-20210408172717732](C:\\Users\\Miatum\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210408172717732.png)\n\n**方法主体**\n\n```java\npackage com.miatum.blog.service;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.mail.SimpleMailMessage;\nimport org.springframework.mail.javamail.JavaMailSender;\nimport org.springframework.stereotype.Service;\n\n/**\n * @Description\n * @ClassName EmailService\n * @Author Miatum\n * @date 2021.04.08 17:05\n */\n@Service\npublic class EmailService {\n    @Value(\"${spring.mail.username}\")\n    private String from;\n    @Autowired\n    private JavaMailSender javaMailSender;\n    public boolean sendTextEmail(String to, String subject, String content) {\n        SimpleMailMessage simpleMailMessage = new SimpleMailMessage();\n        simpleMailMessage.setTo(to);\n        simpleMailMessage.setFrom(from);\n        simpleMailMessage.setSubject(subject);\n        simpleMailMessage.setText(content);\n        try {\n            javaMailSender.send(simpleMailMessage);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return true;\n    }\n}\n```\n\n**Controller**\n\n```java\npackage com.miatum.blog.controller;\n\nimport com.miatum.blog.service.EmailService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n/**\n * @Description\n * @ClassName EmailContraoller\n * @Author Miatum\n * @date 2021.04.08 17:11\n */\n@Controller\n@RequestMapping(\"/api/email\")\npublic class EmailContraoller {\n    @Autowired\n    private EmailService emailService;\n    @RequestMapping(\"/sendTextEmail\")\n    public String sendTextEmail() {\n        String to = \"zhoumq@pvirtech.com\";\n        String subject = \"测试\";\n        String content = \"2021/04/08\";\n        String result = \"发送失败\";\n        if (emailService.sendTextEmail(to, subject, content)) {\n            result = \"发送成功\";\n        }\n        return result;\n    }\n}\n```\n\n**效果**\n\n![image-20210408173022325](C:\\Users\\Miatum\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210408173022325.png)\n\n## 2、问题\n\n### 2.1 空对象转JSON字符串报空指针异常\n\n**解决办法：**未解决', NULL, '0');
INSERT INTO `blog` VALUES (0071, 2, 'Redis简介', '', '', 1, 7, 'miatum', '2021-04-13 02:12:03', '### Redis的安装配置\n1、下载解压\n[下载地址](http://www.redis.cn/download.html)\n![image.png](http://localhost:9001/199311128c8f4a83952c8a8816a84f1b.png)\n解压后，将解压路径写入系统环境变量Path中，以方便后续使用。\n![image.png](http://localhost:9001/2509db4b10df404193a321d3d4de2508.png)\n### Redis的简单使用\n启动redis服务器：redis-server.exe\n连接服务器(需新开另一个终端/cmd)：redis-cli.exe -h 127.0.0.1 -p 6379\n插入：set key value\n查询：get key\n### Spring boot配置Redis\n依赖\n```java\n        <!--redis-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-redis</artifactId>\n            <version>1.4.1.RELEASE</version>\n        </dependency>\n\n```\napplication.properties\n```java\n#redis\nspring.redis.host=127.0.0.1\nspring.redis.port=6379\nspring.redis.password=\nspring.redis.jedis.pool.max-active=8\nspring.redis.jedis.pool.max-wait=-1\nspring.redis.jedis.pool.max-idle=8\nspring.redis.jedis.pool.min-idle=0\nspring.redis.timeout=30000\n\n```\n### Spring boot中使用Redis\nSpring boot中已包含RedisTemplate类，为方便使用，可在其基础上自定义Redis的配置文件和工具类，此步为可选。\n配置文件\n```java\npackage com.miatum.blog.config;\n\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.cache.annotation.CachingConfigurerSupport;\nimport org.springframework.cache.annotation.EnableCaching;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\nimport java.net.UnknownHostException;\n\n/**\n * @Description\n * @ClassName RedisConfig\n * @Author Miatum\n * @date 2021.04.12 15:19\n */\n@Configuration\n@EnableCaching\npublic class RedisConfig extends CachingConfigurerSupport {\n    @Value(\"${spring.redis.host}\")\n    private String host;\n    @Value(\"${spring.redis.port}\")\n    private int port;\n    @Value(\"${spring.redis.timeout}\")\n    private int timeout;\n    @Value(\"${spring.redis.password}\")\n    private String password;\n    @Value(\"${spring.redis.jedis.pool.max-active}\")\n    private int maxActive;\n    @Value(\"${spring.redis.jedis.pool.max-wait}\")\n    private int maxWait;\n    @Value(\"${spring.redis.jedis.pool.max-idle}\")\n    private int maxIdle;\n    @Value(\"${spring.redis.jedis.pool.min-idle}\")\n    private int minIdle;\n    @Bean\n    @SuppressWarnings(\"all\")\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory)\n            throws UnknownHostException {\n        // 我们为了自己开发方便，一般直接使用 <String, Object>\n        RedisTemplate<String, Object> template = new RedisTemplate<String,\n                Object>();\n        template.setConnectionFactory(factory);\n        // Json序列化配置\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new\n                Jackson2JsonRedisSerializer(Object.class);\n        ObjectMapper om = new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n        // String 的序列化\n        StringRedisSerializer stringRedisSerializer = new\n                StringRedisSerializer();\n        // key采用String的序列化方式\n        template.setKeySerializer(stringRedisSerializer);\n        // hash的key也采用String的序列化方式\n        template.setHashKeySerializer(stringRedisSerializer);\n        // value序列化方式采用jackson\n        template.setValueSerializer(jackson2JsonRedisSerializer);\n        // hash的value序列化方式采用jackson\n        template.setHashValueSerializer(jackson2JsonRedisSerializer);\n        template.afterPropertiesSet();\n        return template;\n    }\n}\n\n\n```\n\n工具类\n```java\npackage com.miatum.blog.service;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.stereotype.Component;\n\n/**\n * @Description\n * @ClassName RedisUtil\n * @Author Miatum\n * @date 2021.04.12 15:43\n */\n@Component\npublic class RedisUtil {\n    @Autowired\n    @Qualifier(\"redisTemplate\")\n    private RedisTemplate redisTemplate;\n    public boolean set(final String key, Object value) {\n        redisTemplate.getConnectionFactory().getConnection();\n        try {\n            redisTemplate.opsForValue().set(key, value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n\n    }\n    public Object get(String key) {\n        return key == null ? null : redisTemplate.opsForValue().get(key);\n    }\n}\n\n```\n测试使用\n```java\n@Autowired\n    private BlogService blogService;\n    @Resource\n    private RedisUtil redisUtil;\n    @RequestMapping(\"/selectAllBlog\")\n    @ResponseBody\n    public List<Blog> selectAllBlog() {\n        List<Blog> blogs = blogService.selectAllBlog();\n        System.out.println(blogs.size());\n        redisUtil.set(\"content\", \"测试\");\n        System.out.println(redisUtil.get(\"content\"));\n        return blogService.selectAllBlog();\n    }\n\n```\n![image.png](http://localhost:9001/9def1b46e2d6443a8056071a71874c29.png)\n\n需注意，如果需要存入实体类对象，该实体类需要实现序列化，即implements Serializable。', NULL, '0');
INSERT INTO `blog` VALUES (0072, 2, '二叉查找树', '', '', 1, 41, 'miatum', '2021-04-13 06:55:25', '### 二叉查找树（Binary Search Tree）\n#### 定义\n二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。\n#### 数据结构\n\n```java\npackage algorithm;\n\n/**\n * @Description 给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。\n * @ClassName BinarySearchTree\n * @Author Miatum\n * @date 2021.04.13 14:41\n */\npublic class BinarySearchTree {\n    int val;\n    BinarySearchTree left;\n    BinarySearchTree right;\n    BinarySearchTree(){}\n    BinarySearchTree(int val) {\n        this.val = val;\n    }\n    BinarySearchTree(int val, BinarySearchTree left, BinarySearchTree right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n```\n\n#### 遍历\n```java\n// 中序递归遍历\npublic void inorder(BinarySearchTree root) {\n    if (root != null) {\n        inorder(root.left);\n        System.out.println(root.val);\n        inorder(root.right);\n    }\n}\n\n```\n', NULL, '0');
INSERT INTO `blog` VALUES (0073, 2, '接雨水', '', '', 1, 41, 'miatum', '2021-04-15 02:12:19', '<h6 id=\"题目描述\">题目描述</h6>\n<p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n示例 1：\n<img src=\"http://localhost:9001/996c0fe4d7ce4363afbc589da1089eac.png\" alt=\"image.png\">\n输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\n输出：6\n解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n示例 2：\n输入：height = [4,2,0,3,2,5]\n输出：9\n提示：\nn == height.length\n0 &lt;= n &lt;= 3 * 104\n0 &lt;= height[i] &lt;= 105</p>\n<h6 id=\"解题思路\">解题思路</h6>\n<p>第一步：一个固定锚点i(默认值0)，一个移动锚点j(默认值1)向后遍历，遍历至length - 1处，当height[i] &lt;= height[j]，求两个柱子间能接水数（当i和j相邻时求出的接水数为0），将固定锚点i移至j处，j继续向后遍历。获得正序遍历接水量。\n第二步：当j遍历至末尾，可能出现如示例1情况，即i = 7,但是之后并没有比height[3]更高的柱子了，会忽略掉1个接水数，此时，我们需要按照相同方法从后至前遍历至i处。设固定锚点m（length - 1）,一个移动锚点n(length - 2)向前遍历，遍历至i处,获得逆序遍历接水量。\n第三步：正逆序接水量相加便是总接水量。</p>\n<h6 id=\"代码实现\">代码实现</h6>\n<pre><code class=\"language-java\">class Solution {\n    public int trap(int[] height) {\n        int result = 0; // 接水量\n        int i = 0; // 正序固定锚点\n        for (int j = 1; j &lt; height.length; j++) { // 移动锚点\n            if (height[i] &lt;= height[j]) {\n                result +=getArea(i, j, height);\n                i = j;\n            }\n        }\n        int m = height.length - 1; // 逆序固定锚点\n        for (int n = height.length - 2; n &gt;= i; n--) { // 逆序移动锚点\n            if (height[m] &lt;= height[n]) {\n                result += getArea(m, n, height);\n                m = n;\n            }\n        }\n        return result;\n    }\n    // 求两根柱子间的接水量result，result = 较小柱子高度 x 柱间距 - 间距内的柱子高度和；\n    public int getArea(int i, int j, int[] height) {\n        int result = height[i] * (Math.abs(j - i) -1);\n        if (i &lt; j) {\n            for (int k = i + 1; k &lt; j; k++) {\n                result -= height[k];\n                }\n        } else {\n            for (int k = j + 1; k &lt; i; k++) {\n                result -= height[k];\n            }\n        }        \n        return result;\n    }\n}\n</code></pre>\n', NULL, '1');
INSERT INTO `blog` VALUES (0074, 0, 'N皇后', '回溯', '', 1, 41, 'miatum', '2021-04-20 08:54:33', '#### 问题描述\nn 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。\n每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 \'Q\' 和 \'.\' 分别代表了皇后和空位。\n示例 1：\n![image.png](http://localhost:9001/d583fddda27f4f59963a254635eaa662.png)\n```\n输入：n = 4\n输出：[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\n解释：如上图所示，4 皇后问题存在两个不同的解法。\n\n```\n示例 2：\n\n```\n输入：n = 1\n输出：[[\"Q\"]]\n\n```\n提示：\n\n1 <= n <= 9\n皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。\n#### 解题思路\nN个皇后，棋盘为N行N列，因为不能互相攻击所以每行只能放置一个皇后，采用逐行去放置思路更清晰，每放置一个皇后时，需要将其放置与之前放置在棋盘上的皇后进行位置计算，是否在同一行、列或者斜线上，因此我们需要记录的数据有：行数，列数，皇后位置，斜线信息。数据的重复值对于解题无用，我们直接用HashSet记录即可。\n需要注意的一个点是斜线信息的记录，通过观察我们会发现斜线有两种，即\'/\'和\'\\\'方向，以4*4棋盘为例，左上角第一格为(0, 0)，如果两个皇后在\'/\'方向的斜线上，则两个皇后的\n#### 代码实现\n```java\nclass Solution {\n    public List<List<String>> solveNQueens(int n) {\n        List<List<String>> boards = new ArrayList<List<String>>();\n        int[] queens = new int[n];\n        Set columns = new HashSet<Integer>();\n        Set diagonals1 = new HashSet<Integer>();\n        Set diagonals2 = new HashSet<Integer>();\n        traceBack(boards, columns, diagonals1, diagonals2, queens, n, 0);\n        return boards;\n    }\n    public void traceBack(List<List<String>> boards, Set columns, Set diagonals1, Set diagonals2, int[] queens, int n, int row) {\n        // 当最后一行也放置皇后，则输出答案\n        if (n == row) {\n            generateBoard(boards, queens);\n        } else {\n            for (int i = 0; i < n; i++) {\n                // 同列是否有皇后\n                if (columns.contains(i)) {\n                    continue;\n                }\n                // \'\\\'方向斜线上是否有皇后\n                if (diagonals1.contains(i - row)) {\n                    continue;\n                }\n                //  \'/\'方向斜线上是否有皇后\n                if (diagonals2.contains(i + row)) {\n                    continue;\n                }\n                // 如果以上条件均不满足，则在该位置放置皇后\n                queens[row] = i;\n                columns.add(i);\n                diagonals1.add(i - row);\n                diagonals2.add(i + row);\n                // 当前放置情况下，寻找下一行皇后的可放置位置\n                traceBack(boards, columns, diagonals1, diagonals2, queens, n, row + 1);\n                // 取消当前步骤\n                queens[row] = -1;\n                columns.remove(i);\n                diagonals1.remove(i - row);\n                diagonals2.remove(i + row);\n            }\n        }\n    }\n    public void generateBoard(List<List<String>> boards, int[] queens) {\n        List<String> board = new ArrayList<String>();\n        for (int i = 0; i < queens.length; i++) {\n            char[] row = new char[queens.length];\n            Arrays.fill(row, \'.\');\n            row[queens[i]] = \'Q\';\n            board.add(new String(row));\n        }\n        boards.add(board);\n    }\n}\n\n```\n\n\n', NULL, '0');
INSERT INTO `blog` VALUES (0075, 0, 'Java IO', '', '', 1, 7, 'miatum', '2021-04-22 09:26:22', '程序即获取并处理输入，输出结果的一个产品。可想而知IO是一门编程语言的重要组成。\n![image.png](http://localhost:9001/6772a901cdc547ca8f56cb2ed2b1bf85.png)', NULL, '0');

-- ----------------------------
-- Table structure for email
-- ----------------------------
DROP TABLE IF EXISTS `email`;
CREATE TABLE `email`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of email
-- ----------------------------
INSERT INTO `email` VALUES (2, '1437449691@qq.com');
INSERT INTO `email` VALUES (5, 'zhoumq@pvirtech.com');

-- ----------------------------
-- Table structure for state
-- ----------------------------
DROP TABLE IF EXISTS `state`;
CREATE TABLE `state`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `state_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of state
-- ----------------------------
INSERT INTO `state` VALUES (0, '新建');
INSERT INTO `state` VALUES (1, '保密');
INSERT INTO `state` VALUES (2, '公开');

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag`  (
  `id` int(4) NOT NULL AUTO_INCREMENT,
  `tag_name` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 42 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tag
-- ----------------------------
INSERT INTO `tag` VALUES (1, 'layui');
INSERT INTO `tag` VALUES (7, 'Java');
INSERT INTO `tag` VALUES (8, 'sql');
INSERT INTO `tag` VALUES (9, 'thymeleaf');
INSERT INTO `tag` VALUES (10, 'css');
INSERT INTO `tag` VALUES (11, 'JavaScript');
INSERT INTO `tag` VALUES (12, 'mybatis');
INSERT INTO `tag` VALUES (15, '恋爱');
INSERT INTO `tag` VALUES (16, 'editor.md');
INSERT INTO `tag` VALUES (17, 'HTML');
INSERT INTO `tag` VALUES (23, 'spring boot');
INSERT INTO `tag` VALUES (25, '老歌');
INSERT INTO `tag` VALUES (26, '战争');
INSERT INTO `tag` VALUES (27, 'nginx');
INSERT INTO `tag` VALUES (28, 'VUE');
INSERT INTO `tag` VALUES (29, 'mavonEditor');
INSERT INTO `tag` VALUES (30, '服务器');
INSERT INTO `tag` VALUES (31, 'Linux');
INSERT INTO `tag` VALUES (32, 'Oracle');
INSERT INTO `tag` VALUES (33, '旅游');
INSERT INTO `tag` VALUES (34, 'mac OS');
INSERT INTO `tag` VALUES (35, '生活');
INSERT INTO `tag` VALUES (36, 'VM ware');
INSERT INTO `tag` VALUES (37, 'IDEA');
INSERT INTO `tag` VALUES (38, 'FFmpeg');
INSERT INTO `tag` VALUES (39, '动漫');
INSERT INTO `tag` VALUES (40, '台湾电影');
INSERT INTO `tag` VALUES (41, '算法');

-- ----------------------------
-- Table structure for type
-- ----------------------------
DROP TABLE IF EXISTS `type`;
CREATE TABLE `type`  (
  `id` int(4) NOT NULL AUTO_INCREMENT,
  `type_name` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `type_name_en` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 44 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of type
-- ----------------------------
INSERT INTO `type` VALUES (1, '编程', 'Code');
INSERT INTO `type` VALUES (8, '记事', ' Diary');
INSERT INTO `type` VALUES (35, '影视', 'Video');
INSERT INTO `type` VALUES (37, '音乐', 'Music');
INSERT INTO `type` VALUES (41, '手工', 'Manual');
INSERT INTO `type` VALUES (42, '街舞', 'Breaking');
INSERT INTO `type` VALUES (43, '硬件', 'Hardware');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` int(4) UNSIGNED ZEROFILL NOT NULL AUTO_INCREMENT,
  `name` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `password` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (0001, 'miatum', 'yyt0320');

SET FOREIGN_KEY_CHECKS = 1;
